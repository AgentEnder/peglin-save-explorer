using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.AssetCreation;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_212;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Extensions;
using peglin_save_explorer.Data;
using peglin_save_explorer.UI;
using peglin_save_explorer.Utils;
using peglin_save_explorer.Core;
using peglin_save_explorer.Services;
using peglin_save_explorer.Extractors.Models;
using peglin_save_explorer.Extractors.Services;

namespace peglin_save_explorer.Extractors
{
    /// <summary>
    /// Unified extractor that processes all assets in a single pass while maintaining AssetRipper context
    /// This ensures proper PPtr resolution for accurate entity-sprite correlation
    /// </summary>
    public class UnifiedAssetExtractor
    {
        private readonly ConsoleSession? _session;
        private readonly EnumExtractor _enumExtractor = new();
        private readonly EntityDetectionService _entityDetectionService;
        private readonly EntityExtractionService _entityExtractionService;
        private readonly SpriteProcessingService _spriteProcessingService;
        private readonly AssetProcessingService _assetProcessingService;
        private readonly LocalizationProcessingService _localizationProcessingService;
        
        private string? _currentPeglinPath;
        private LocalizationService _localizationService = LocalizationService.Instance;
        private Dictionary<string, string>? _globalRelicParameters;

        public UnifiedAssetExtractor(ConsoleSession? session = null)
        {
            _session = session;
            _entityDetectionService = new EntityDetectionService();
            _entityExtractionService = new EntityExtractionService();
            _spriteProcessingService = new SpriteProcessingService();
            _assetProcessingService = new AssetProcessingService();
            _localizationProcessingService = new LocalizationProcessingService();
        }

        /// <summary>
        /// Extracts all assets from a Peglin installation in a single pass with full cross-bundle reference resolution
        /// </summary>
        public UnifiedExtractionResult ExtractAllAssetsFromPeglinInstall(string peglinPath, IProgress<string>? progress = null)
        {
            _currentPeglinPath = peglinPath;
            var result = new UnifiedExtractionResult();
            _enumExtractor.LoadAssembly(peglinPath);
            _localizationService.EnsureLoaded();
            try
            {
                var bundleDirectory = PeglinPathHelper.GetStreamingAssetsBundlePath(peglinPath);
                if (string.IsNullOrEmpty(bundleDirectory) || !Directory.Exists(bundleDirectory))
                {
                    Logger.Error($"Bundle directory not found for: {peglinPath}");
                    return result;
                }

                progress?.Report($"üîç Scanning bundle directory: {bundleDirectory}");
                var bundleFiles = Directory.GetFiles(bundleDirectory, "*.bundle", SearchOption.AllDirectories);
                var assetFiles = Directory.GetFiles(bundleDirectory, "*.assets", SearchOption.AllDirectories);
                var allFiles = bundleFiles.Concat(assetFiles).ToArray();
                progress?.Report($"üì¶ Found {bundleFiles.Length} bundle files and {assetFiles.Length} assets files to process ({allFiles.Length} total)");

                // Load ALL bundles at once to enable cross-bundle reference resolution
                progress?.Report($"üöÄ Loading all bundles with dependency resolution...");
                var gameBundle = ProcessAllBundlesWithDependencies(allFiles, result, progress);

                // Consolidate orbs into families after extraction
                _localizationProcessingService.ConsolidateOrbsIntoFamilies(result.Orbs, result.OrbFamilies);

                var relicSprites = result.Sprites.Values.Count(s => s.Type == SpriteCacheManager.SpriteType.Relic);
                var enemySprites = result.Sprites.Values.Count(s => s.Type == SpriteCacheManager.SpriteType.Enemy);
                var orbSprites = result.Sprites.Values.Count(s => s.Type == SpriteCacheManager.SpriteType.Orb);

                progress?.Report($"‚úÖ Extracted {result.Relics.Count} relics, {result.Enemies.Count} enemies, {result.Orbs.Count} orbs ({result.OrbFamilies.Count} families), {result.Sprites.Count} sprites");
                progress?.Report($"   üìä Sprite breakdown: {relicSprites} relic sprites, {enemySprites} enemy sprites, {orbSprites} orb sprites");
                progress?.Report($"üîó Correlated {result.RelicSpriteCorrelations.Count} relics, {result.EnemySpriteCorrelations.Count} enemies, {result.OrbSpriteCorrelations.Count} orbs with sprites");

                return result;
            }
            catch (Exception ex)
            {
                Logger.Error($"Error during unified extraction: {ex.Message}");
                return result;
            }
        }

        /// <summary>
        /// Processes ALL bundle files at once to enable cross-bundle reference resolution
        /// </summary>
        private GameBundle ProcessAllBundlesWithDependencies(string[] bundlePaths, UnifiedExtractionResult result, IProgress<string>? progress = null)
        {
            try
            {
                // Create assembly manager for asset creation
                var assemblyManager = new BaseManager(s => { });
                var assetFactory = new GameAssetFactory(assemblyManager);

                // Load ALL bundles at once - this is crucial for cross-bundle PPtr resolution
                // GameBundle.FromPaths automatically initializes dependency lists for cross-bundle references
                progress?.Report($"   üîÑ Loading {bundlePaths.Length} bundles with full dependency resolution...");
                var gameBundle = GameBundle.FromPaths(bundlePaths, assetFactory);

                progress?.Report($"   üìä Processing {gameBundle.FetchAssetCollections().Count()} asset collections...");

                // Create shared sprite reference dictionaries that persist across all collections
                // This is crucial for orb sprite correlation since orbs and their PachinkoBall sprites
                // are often in different collections
                var orbSpriteRefs = new Dictionary<string, IUnityAssetBase>(); // gameObject_PathID -> sprite asset reference

                // Two-phase processing across ALL collections to ensure global relic parameters are available
                var collections = gameBundle.FetchAssetCollections().ToList();
                int processedCollections = 0;

                // PHASE 1: Extract global relic parameters from ALL collections first
                Logger.Debug($"üî§ Phase 1: Extracting global relic parameters from {collections.Count} collections");
                foreach (var collection in collections)
                {
                    try
                    {
                        ExtractGlobalParametersFromCollection(collection);
                    }
                    catch (Exception ex)
                    {
                        Logger.Warning($"Error extracting global parameters from collection {collection.Name}: {ex.Message}");
                    }
                }
                Logger.Debug($"üî§ Phase 1 complete: {_globalRelicParameters?.Count ?? 0} global relic parameters available");

                // PHASE 2: Process all collections with global parameters available
                foreach (var collection in collections)
                {
                    processedCollections++;
                    progress?.Report($"   üìÅ Processing collection {processedCollections}/{collections.Count}: {collection.Name}");

                    try
                    {
                        ProcessCollectionWithCrossReferences(collection, gameBundle, result, orbSpriteRefs);
                    }
                    catch (Exception ex)
                    {
                        Logger.Warning($"Error processing collection {collection.Name}: {ex.Message}");
                    }
                }

                return gameBundle;
            }
            catch (ArgumentException ex) when (ex.Message.Contains("No SerializedFile found"))
            {
                Logger.Warning("Some bundles were not valid Unity bundles and were skipped");
                throw;
            }
            catch (Exception ex)
            {
                Logger.Error($"Error processing bundles with dependencies: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Processes an asset collection with full cross-bundle reference resolution
        /// </summary>
        private void ProcessCollectionWithCrossReferences(AssetCollection collection, GameBundle gameBundle, UnifiedExtractionResult result, Dictionary<string, IUnityAssetBase> orbSpriteRefs)
        {
            try
            {
                // Step 1: Build sprite information lookup tables from SpriteInformationObject assets
                var spriteInfoLookup = BuildSpriteInformationLookup(collection, gameBundle);
                Logger.Debug($"üó∫Ô∏è Built sprite information lookup with {spriteInfoLookup.Count} mappings");

                // Step 2: Extract entity data (relics, enemies, orbs) and collect sprite references
                var relicSpriteRefs = new Dictionary<string, IUnityAssetBase>(); // relic ID -> sprite asset reference
                var enemySpriteRefs = new Dictionary<string, IUnityAssetBase>(); // enemy ID -> sprite asset reference
                // orbSpriteRefs is now passed in from ProcessAllBundlesWithDependencies to persist across collections

                // Create a map of component PathID to component for GameObject processing
                var componentMap = new Dictionary<long, IMonoBehaviour>();

                // First pass: collect MonoBehaviour components into map (without processing them yet)
                foreach (var asset in collection.Assets)
                {
                    if (asset.Value is IMonoBehaviour monoBehaviour)
                    {
                        componentMap[monoBehaviour.PathID] = monoBehaviour;
                    }
                }

                // Second pass: process GameObjects first to extract global parameters (like relic localization)
                var gameObjectCount = 0;
                var processedGameObjects = 0;
                foreach (var asset in collection.Assets)
                {
                    if (asset.Value is IGameObject gameObject)
                    {
                        gameObjectCount++;
                        Logger.Debug($"üéÆ Processing GameObject: {gameObject.Name} (PathID: {gameObject.PathID})");
                        ProcessGameObjectForOrbs(gameObject, componentMap, result, orbSpriteRefs, collection);
                        processedGameObjects++;
                    }
                }

                // Third pass: process MonoBehaviour components now that global parameters are available
                foreach (var monoBehaviour in componentMap.Values)
                {
                    ProcessMonoBehaviour(monoBehaviour, collection, gameBundle, result, relicSpriteRefs, enemySpriteRefs, orbSpriteRefs);
                }
                Logger.Verbose($"üéÆ Processed {processedGameObjects} GameObjects out of {gameObjectCount} found in collection");

                // Step 2: Extract sprites and textures
                var processedSprites = new HashSet<long>(); // Track processed PathIDs to avoid duplicates

                // Process Sprite assets
                foreach (var sprite in collection.OfType<ISprite>())
                {
                    if (processedSprites.Contains(sprite.PathID))
                        continue;

                    var spriteMetadata = ExtractSpriteWithImprovedProcessing(sprite);
                    if (spriteMetadata != null)
                    {
                        result.Sprites[spriteMetadata.Id] = spriteMetadata;
                        processedSprites.Add(sprite.PathID);
                        Logger.Verbose($"‚úÖ Processed ISprite: {sprite.Name} -> {spriteMetadata.Id}");
                    }
                }

                // Process ALL other assets to find sprite-related types we might be missing
                Logger.Verbose($"üîç Scanning {collection.Assets.Count} total assets for sprite-related types...");
                var assetTypeCounts = new Dictionary<string, int>();

                foreach (var asset in collection.Assets)
                {
                    var assetType = asset.Value?.GetType()?.Name ?? "Unknown";
                    if (!assetTypeCounts.ContainsKey(assetType))
                        assetTypeCounts[assetType] = 0;
                    assetTypeCounts[assetType]++;

                    // Look for potential sprite-related assets we're not processing
                    if (asset.Value != null && !processedSprites.Contains(asset.Key))
                    {
                        var assetName = asset.Value.ToString() ?? "";

                        // Check for sprite-like asset types or names
                        if (assetType.Contains("Sprite", StringComparison.OrdinalIgnoreCase) ||
                            assetName.Contains("sprite", StringComparison.OrdinalIgnoreCase) ||
                            assetName.Contains("relic", StringComparison.OrdinalIgnoreCase) ||
                            assetName.Contains("orb", StringComparison.OrdinalIgnoreCase) ||
                            (assetType == "Texture2D" && (assetName.Contains("relic", StringComparison.OrdinalIgnoreCase) ||
                                                          assetName.Contains("orb", StringComparison.OrdinalIgnoreCase))))
                        {
                            Logger.Debug($"üéØ Found potential sprite asset: {assetType} - {assetName} (PathID: {asset.Key})");

                            // Try to process as sprite-related asset
                            var collectionName = collection.Name ?? "unknown";
                            var potentialSpriteMetadata = ProcessPotentialSpriteAsset(asset.Value, collectionName);
                            if (potentialSpriteMetadata != null)
                            {
                                if (!result.Sprites.ContainsKey(potentialSpriteMetadata.Id)) // Avoid duplicates
                                {
                                    result.Sprites[potentialSpriteMetadata.Id] = potentialSpriteMetadata;
                                    processedSprites.Add(asset.Key);
                                    Logger.Debug($"‚úÖ Successfully processed potential sprite: {potentialSpriteMetadata.Name}");
                                }
                            }
                        }
                    }
                }

                // Log asset type summary for debugging
                var topAssetTypes = assetTypeCounts.OrderByDescending(kvp => kvp.Value).Take(10);
                Logger.Debug($"üìä Top asset types in collection: {string.Join(", ", topAssetTypes.Select(kvp => $"{kvp.Key}({kvp.Value})"))}");
                Logger.Debug($"üé® Found {collection.OfType<ISprite>().Count()} ISprite assets in collection");

                // Process Texture2D assets (standalone textures not referenced by sprites)
                foreach (var texture in collection.OfType<ITexture2D>())
                {
                    if (processedSprites.Contains(texture.PathID))
                        continue;

                    var spriteMetadata = ExtractTexture(texture);
                    if (spriteMetadata != null)
                    {
                        result.Sprites[spriteMetadata.Id] = spriteMetadata;
                        processedSprites.Add(texture.PathID);
                    }
                }

                // Step 3: Resolve sprite references and build correlations
                // This is the key improvement - we resolve references while AssetRipper context is still active
                foreach (var kvp in relicSpriteRefs)
                {
                    var relicId = kvp.Key;
                    var spriteRef = kvp.Value;

                    // Try to resolve the sprite reference with cross-bundle support and sprite info lookup
                    var resolvedSprite = ResolveSpriteWithLookup(spriteRef, gameBundle, spriteInfoLookup, SpriteCacheManager.SpriteType.Relic);
                    if (resolvedSprite != null)
                    {

                        // Always update/add the sprite with the correct type (overwrite if it exists with wrong type)
                        result.Sprites[resolvedSprite.Id] = resolvedSprite;

                        // Create correlation
                        result.RelicSpriteCorrelations[relicId] = resolvedSprite.Id;

                        // Update the relic data with correlation info
                        if (result.Relics.TryGetValue(relicId, out var relic))
                        {
                            relic.CorrelatedSpriteId = resolvedSprite.Id;
                            relic.SpriteFilePath = resolvedSprite.FilePath;
                            relic.CorrelationConfidence = 1.0f; // Direct resolution = 100% confidence
                            relic.CorrelationMethod = "Direct PPtr Resolution";
                        }

                        Logger.Verbose($"‚úÖ Successfully correlated relic {relicId} with sprite {resolvedSprite.Id} -> {resolvedSprite.FilePath}");
                    }
                    else
                    {
                        // Sprite resolution failed - dump the asset to understand its structure
                        var relicName = result.Relics.TryGetValue(relicId, out var relicData) ? relicData.Name : "Unknown";
                        Logger.Warning($"‚ùå Failed to resolve sprite for relic {relicId} ({relicName}) - sprite reference type: {spriteRef.GetType().Name}");
                        if (spriteRef is IUnityObjectBase objBase)
                        {
                            DumpAssetPropertiesForAnalysis(objBase, $"FailedRelic_{relicId}_{spriteRef.GetType().Name}");
                        }
                        else
                        {
                            Logger.Warning($"‚ùå Cannot dump asset properties - spriteRef is {spriteRef.GetType().Name}, not IUnityObjectBase");
                        }
                    }
                }

                foreach (var kvp in enemySpriteRefs)
                {
                    var enemyId = kvp.Key;
                    var spriteRef = kvp.Value;

                    var resolvedSprite = ResolveSpriteWithLookup(spriteRef, gameBundle, spriteInfoLookup, SpriteCacheManager.SpriteType.Enemy);
                    if (resolvedSprite != null)
                    {

                        // Always update/add the sprite with the correct type (overwrite if it exists with wrong type)
                        result.Sprites[resolvedSprite.Id] = resolvedSprite;

                        result.EnemySpriteCorrelations[enemyId] = resolvedSprite.Id;

                        if (result.Enemies.TryGetValue(enemyId, out var enemy))
                        {
                            enemy.CorrelatedSpriteId = resolvedSprite.Id;
                            enemy.SpriteFilePath = resolvedSprite.FilePath;
                            enemy.CorrelationConfidence = 1.0f;
                            enemy.CorrelationMethod = "Direct PPtr Resolution";
                        }

                        Logger.Debug($"Correlated enemy {enemyId} with sprite {resolvedSprite.Id}");
                    }
                }

                foreach (var kvp in orbSpriteRefs)
                {
                    var orbId = kvp.Key;
                    var spriteRef = kvp.Value;

                    var resolvedSprite = ResolveSpriteWithLookup(spriteRef, gameBundle, spriteInfoLookup, SpriteCacheManager.SpriteType.Orb);
                    if (resolvedSprite != null)
                    {

                        // Always update/add the sprite with the correct type (overwrite if it exists with wrong type)  
                        result.Sprites[resolvedSprite.Id] = resolvedSprite;

                        result.OrbSpriteCorrelations[orbId] = resolvedSprite.Id;

                        if (result.Orbs.TryGetValue(orbId, out var orb))
                        {
                            orb.CorrelatedSpriteId = resolvedSprite.Id;
                            orb.SpriteFilePath = resolvedSprite.FilePath;
                            orb.CorrelationConfidence = 1.0f;
                            orb.CorrelationMethod = "PachinkoBall Tracing";
                        }

                        Logger.Debug($"Correlated orb {orbId} with sprite {resolvedSprite.Id}");
                    }
                }

                // DEBUG: Detailed correlation analysis
                Logger.Debug($"=== CORRELATION DEBUG ANALYSIS ===");
                Logger.Debug($"üìä Total orbs found: {result.Orbs.Count}");
                Logger.Debug($"üìä Total sprite references stored: {orbSpriteRefs.Count}");

                // Log all available sprite reference keys
                Logger.Debug($"üîë Available sprite reference keys:");
                foreach (var key in orbSpriteRefs.Keys.Take(20))
                {
                    Logger.Debug($"  - {key}");
                }

                // Log sample orb PathIDs
                Logger.Debug($"üéÆ Sample orb PathIDs:");
                foreach (var orbEntry in result.Orbs.Take(10))
                {
                    var orb = orbEntry.Value;
                    if (orb.RawData != null && orb.RawData.TryGetValue("PathID", out var pathIDObj))
                    {
                        Logger.Debug($"  - Orb '{orb.Id}': PathID = {pathIDObj} (GameObject key would be: gameObject_{pathIDObj})");
                    }
                    else
                    {
                        Logger.Debug($"  - Orb '{orb.Id}': NO PathID found in RawData");
                        if (orb.RawData != null)
                        {
                            Logger.Debug($"    RawData keys: {string.Join(", ", orb.RawData.Keys.Take(10))}");
                        }
                    }
                }

                // ADDITIONAL CORRELATION STEP: Correlate remaining orbs with PachinkoBall sprites using GameObject PathID
                var additionalCorrelationCount = 0;
                var orbsWithoutPathID = 0;
                var orbsWithPathIDButNoMatch = 0;

                foreach (var orbEntry in result.Orbs.ToList())
                {
                    var orb = orbEntry.Value;
                    // Check if this orb still needs correlation and has a GameObject PathID
                    if (string.IsNullOrEmpty(orb.CorrelatedSpriteId) && orb.RawData != null &&
                        orb.RawData.TryGetValue("PathID", out var orbPathIDObj) && orbPathIDObj is long orbPathID)
                    {
                        // Look for a PachinkoBall sprite with matching GameObject PathID
                        var gameObjectKey = $"gameObject_{orbPathID}";
                        Logger.Debug($"üîç Looking for sprite with key: {gameObjectKey} for orb {orb.Id}");
                        Logger.Debug($"üîç orbSpriteRefs dictionary has {orbSpriteRefs.Count} keys at correlation time");
                        Logger.Debug($"üîç orbSpriteRefs keys near match: {string.Join(", ", orbSpriteRefs.Keys.Where(k => k.Contains(orbPathID.ToString())).Take(3))}");

                        bool keyExists = orbSpriteRefs.ContainsKey(gameObjectKey);
                        Logger.Debug($"üîç ContainsKey({gameObjectKey}) = {keyExists}");
                        if (keyExists)
                        {
                            Logger.Debug($"üéØ ENTERING CORRELATION BRANCH for orb {orb.Id}");
                            var pachinkoBallSprite = orbSpriteRefs[gameObjectKey];
                            Logger.Debug($"üéØ Retrieved pachinkoBallSprite: {pachinkoBallSprite?.GetType().Name}");

                            // Resolve the sprite and get its file path
                            // ResolveSpriteWithLookup handles both IUnityObjectBase and PPtr types
                            var resolvedSprite = ResolveSpriteWithLookup(pachinkoBallSprite, gameBundle, spriteInfoLookup, SpriteCacheManager.SpriteType.Orb);
                            Logger.Debug($"üéØ ResolveSpriteWithLookup returned: {resolvedSprite?.Id ?? "NULL"}");

                            if (resolvedSprite != null)
                            {
                                orb.CorrelatedSpriteId = resolvedSprite.Id;
                                orb.SpriteFilePath = resolvedSprite.FilePath;
                                orb.CorrelationMethod = "PachinkoBall GameObject PathID";
                                orb.CorrelationConfidence = 1.0f;
                                additionalCorrelationCount++;

                                // Also add to sprite correlations and make sure sprite is in result
                                result.OrbSpriteCorrelations[orb.Id] = resolvedSprite.Id;
                                result.Sprites[resolvedSprite.Id] = resolvedSprite;

                                Logger.Debug($"üéØ ADDITIONAL CORRELATION! Orb {orb.Id} with PachinkoBall sprite {resolvedSprite.Id} -> {resolvedSprite.FilePath} (GameObject PathID: {orbPathID})");
                            }
                            else
                            {
                                Logger.Debug($"‚ùå Failed to resolve PachinkoBall sprite for orb {orb.Id} (GameObject PathID: {orbPathID})");
                            }
                        }
                        else
                        {
                            orbsWithPathIDButNoMatch++;
                            Logger.Debug($"‚ùå No sprite found for key {gameObjectKey} (orb: {orb.Id})");
                        }
                    }
                    else if (string.IsNullOrEmpty(orb.CorrelatedSpriteId))
                    {
                        orbsWithoutPathID++;
                    }
                }

                Logger.Debug($"üîó Additional PachinkoBall correlations: {additionalCorrelationCount}");
                Logger.Debug($"üìä Orbs without PathID: {orbsWithoutPathID}");
                Logger.Debug($"üìä Orbs with PathID but no match: {orbsWithPathIDButNoMatch}");

            }
            catch (Exception ex)
            {
                Logger.Error($"Error processing collection: {ex.Message}");
            }
        }

        /// <summary>
        /// Processes a MonoBehaviour to extract entity data and sprite references
        /// </summary>
        private void ProcessMonoBehaviour(
            IMonoBehaviour monoBehaviour,
            AssetCollection collection,
            GameBundle gameBundle,
            UnifiedExtractionResult result,
            Dictionary<string, IUnityAssetBase> relicSpriteRefs,
            Dictionary<string, IUnityAssetBase> enemySpriteRefs,
            Dictionary<string, IUnityAssetBase> orbSpriteRefs)
        {
            try
            {
                var structure = monoBehaviour.LoadStructure();
                if (structure == null) return;

                var data = ConvertStructureToDict(structure, collection, out var spriteReference);

                // Determine entity type and extract accordingly
                if (IsRelicData(data))
                {
                    // Use global relic parameters for token resolution
                    if (_globalRelicParameters != null && _globalRelicParameters.Count > 0)
                    {
                        Logger.Debug($"üî§ Using {_globalRelicParameters.Count} global relic parameters for relic {monoBehaviour.Name}");
                    }
                    else
                    {
                        Logger.Debug($"üî§ No global relic parameters available for relic {monoBehaviour.Name}");
                    }
                    var relic = ExtractRelic(monoBehaviour.Name, data, _globalRelicParameters);
                    if (relic != null && !string.IsNullOrEmpty(relic.Id))
                    {
                        result.Relics[relic.Id] = relic;

                        // Store sprite reference if found
                        if (spriteReference != null)
                        {
                            relicSpriteRefs[relic.Id] = spriteReference;
                            Logger.Debug($"üîÆ Found sprite reference for relic {relic.Id}: {spriteReference.GetType().Name}");
                        }
                        else
                        {
                            Logger.Debug($"üîÆ No sprite reference found for relic {relic.Id}");
                        }

                        Logger.Debug($"Found relic: {relic.Id} - {relic.Name}");
                    }
                }
                else if (IsEnemyData(data))
                {
                    var enemy = ExtractEnemy(monoBehaviour.Name, data);
                    if (enemy != null && !string.IsNullOrEmpty(enemy.Id))
                    {
                        result.Enemies[enemy.Id] = enemy;

                        if (spriteReference != null)
                        {
                            enemySpriteRefs[enemy.Id] = spriteReference;
                            Logger.Debug($"üëπ Found sprite reference for enemy {enemy.Id}: {spriteReference.GetType().Name}");
                        }
                        else
                        {
                            Logger.Debug($"üëπ No sprite reference found for enemy {enemy.Id}");
                        }

                        Logger.Debug($"Found enemy: {enemy.Id} - {enemy.Name}");
                    }
                }
                // NOTE: Orb extraction is now handled in ProcessGameObjectForOrbs during GameObject processing
                // This ensures proper correlation with PachinkoBall sprites using GameObject PathIDs
                // else if (IsOrbData(data)) { ... }
                // Also check for PachinkoBall MonoBehaviours with _renderer fields
                else if (IsPachinkoBallData(data))
                {
                    Logger.Debug($"üéØ Found PachinkoBall MonoBehaviour: {monoBehaviour.Name}, PathID: {monoBehaviour.PathID}");
                    Logger.Debug($"üéØ PachinkoBall data keys: {string.Join(", ", data.Keys.Take(10))}");

                    // Get GameObject PathID from the MonoBehaviour's GameObject property
                    string? gameObjectKey = null;
                    if (monoBehaviour.GameObject != null && !monoBehaviour.GameObject.IsNull())
                    {
                        gameObjectKey = $"gameObject_{monoBehaviour.GameObject.PathID}";
                        Logger.Debug($"üéØ PachinkoBall belongs to GameObject with PathID: {monoBehaviour.GameObject.PathID}");
                    }
                    else
                    {
                        Logger.Debug($"‚ùå PachinkoBall MonoBehaviour GameObject property is null or empty");
                    }

                    if (data.ContainsKey("_renderer"))
                    {
                        Logger.Debug($"üéØ PachinkoBall HAS _renderer field: {data["_renderer"]}");

                        // Try to extract sprite from _renderer field
                        var rendererField = data["_renderer"];
                        if (rendererField is Dictionary<string, object> rendererDict)
                        {
                            Logger.Debug($"üéØ _renderer is PPtr with keys: {string.Join(", ", rendererDict.Keys)}");

                            // This is a PPtr reference to a SpriteRenderer
                            if (rendererDict.ContainsKey("pathId") && rendererDict["pathId"] != null)
                            {
                                var pathIdStr = rendererDict["pathId"].ToString();
                                if (long.TryParse(pathIdStr, out var pathId))
                                {
                                    Logger.Debug($"üéØ Following _renderer PPtr to pathId: {pathId}");

                                    // Resolve the SpriteRenderer by PathID
                                    var spriteRenderer = collection.TryGetAsset(pathId);
                                    if (spriteRenderer != null)
                                    {
                                        Logger.Debug($"‚úÖ Resolved SpriteRenderer: {spriteRenderer.GetType().Name}, Type: {spriteRenderer.GetType().FullName}");
                                        Logger.Debug($"   Is ISpriteRenderer: {spriteRenderer is ISpriteRenderer}");
                                        Logger.Debug($"   Is IMonoBehaviour: {spriteRenderer is IMonoBehaviour}");

                                        // Now extract the sprite from the SpriteRenderer
                                        // SpriteRenderer is NOT a MonoBehaviour, it's a Component with m_Sprite field
                                        try
                                        {
                                            // Try to access the sprite via the ISpriteRenderer interface if available
                                            if (spriteRenderer is ISpriteRenderer renderer)
                                            {
                                                // Use reflection to find the m_Sprite property since we don't know the exact property name
                                                var spriteProperty = renderer.GetType().GetProperty("M_Sprite")
                                                    ?? renderer.GetType().GetProperty("Sprite_C212P")
                                                    ?? renderer.GetType().GetProperty("Sprite");

                                                if (spriteProperty != null)
                                                {
                                                    var spritePPtr = spriteProperty.GetValue(renderer);
                                                    if (spritePPtr != null)
                                                    {
                                                        // The sprite property returns a PPtr, we need to resolve it
                                                        var sprite = ResolvePPtr(spritePPtr, collection);
                                                        if (sprite != null)
                                                        {
                                                            // Use GameObject key if available, otherwise fall back to MonoBehaviour PathID
                                                            var spriteKey = gameObjectKey ?? $"pachinkoBall_{monoBehaviour.PathID}";
                                                            orbSpriteRefs[spriteKey] = sprite;
                                                            Logger.Debug($"üéØ Extracted sprite from SpriteRenderer: {sprite.GetType().Name}, stored with key: {spriteKey}");

                                                            // Log sprite name if available
                                                            if (sprite is INamed namedSprite)
                                                            {
                                                                Logger.Debug($"   Sprite name: {namedSprite.Name}");
                                                            }

                                                        }
                                                        else
                                                        {
                                                            Logger.Debug($"‚ùå Could not resolve sprite PPtr from SpriteRenderer");
                                                        }
                                                    }
                                                    else
                                                    {
                                                        Logger.Debug($"‚ùå Sprite property was null on SpriteRenderer");
                                                    }
                                                }
                                                else
                                                {
                                                    Logger.Debug($"‚ùå No m_Sprite property found on SpriteRenderer type {renderer.GetType().Name}");
                                                    // Log available properties for debugging
                                                    var props = renderer.GetType().GetProperties().Select(p => p.Name);
                                                    Logger.Debug($"   Available properties: {string.Join(", ", props.Take(10))}");
                                                }
                                            }
                                            else
                                            {
                                                Logger.Debug($"‚ùå SpriteRenderer is not ISpriteRenderer: {spriteRenderer.GetType().Name}");
                                            }
                                        }
                                        catch (Exception ex)
                                        {
                                            Logger.Debug($"‚ùå Error extracting sprite from SpriteRenderer: {ex.Message}");
                                        }
                                    }
                                    else
                                    {
                                        Logger.Debug($"‚ùå Could not resolve SpriteRenderer at pathId: {pathId}");
                                    }
                                }
                            }
                        }
                        else if (rendererField is IUnityAssetBase spriteAsset)
                        {
                            var tempKey = $"pachinkoBall_{monoBehaviour.PathID}";
                            orbSpriteRefs[tempKey] = spriteAsset;
                            Logger.Debug($"üéØ Direct sprite asset from PachinkoBall _renderer: {spriteAsset.GetType().Name}");
                        }
                        else
                        {
                            Logger.Debug($"üéØ _renderer field is not Dictionary or IUnityAssetBase, type: {rendererField?.GetType()?.Name}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error processing MonoBehaviour: {ex.Message}");
            }
        }

        /// <summary>
        /// Converts a SerializableStructure to a dictionary and extracts sprite references
        /// </summary>
        private Dictionary<string, object> ConvertStructureToDict(
            SerializableStructure structure,
            AssetCollection collection,
            out IUnityAssetBase? spriteReference)
        {
            var result = new Dictionary<string, object>();
            spriteReference = null;

            foreach (var field in structure.Type.Fields)
            {
                try
                {
                    if (structure.TryGetField(field.Name, out var value))
                    {
                        var fieldName = field.Name.ToLowerInvariant();
                        var convertedValue = ConvertSerializableValue(value, field, collection);

                        result[field.Name] = convertedValue;

                        // Debug: Log all field names with asset references to understand data structure
                        if (value.CValue is IUnityAssetBase debugAsset)
                        {
                            Logger.Debug($"üîç Field '{field.Name}' has asset reference: {debugAsset.GetType().Name}");

                            // For orbs, prioritize the main "sprite" field over status effect icons
                            if (spriteReference == null)
                            {
                                if (field.Name.Equals("sprite", StringComparison.OrdinalIgnoreCase))
                                {
                                    spriteReference = debugAsset;
                                    Logger.Debug($"üéØ Found main sprite field '{field.Name}' with asset type: {debugAsset.GetType().Name}");
                                }
                                else if (IsSpriteField(fieldName))
                                {
                                    spriteReference = debugAsset;
                                    Logger.Debug($"üéØ Found sprite field '{field.Name}' with asset type: {debugAsset.GetType().Name}");
                                }
                                else if (CouldBeSpriteField(field.Name))
                                {
                                    Logger.Debug($"ü§î Field '{field.Name}' might be sprite-related, investigating...");
                                    spriteReference = debugAsset;
                                }
                            }
                            // If we already found a sprite reference but this is the main "sprite" field, override it
                            else if (field.Name.Equals("sprite", StringComparison.OrdinalIgnoreCase))
                            {
                                Logger.Debug($"üîÑ Overriding with main sprite field '{field.Name}' (was using other sprite field)");
                                spriteReference = debugAsset;
                            }
                        }
                        // Also check for GUID-based asset references (Unity Addressables)
                        else if (spriteReference == null && CouldBeSpriteField(field.Name) && IsGuidAssetReference(convertedValue))
                        {
                            Logger.Debug($"üéØ Found GUID-based sprite reference in field '{field.Name}': {convertedValue}");
                            // For GUID references, we can't resolve them immediately but we can note that this entity has a sprite reference
                            // We'll handle GUID resolution differently since AssetRipper might not be able to resolve these cross-bundle
                        }
                    }
                }
                catch
                {
                    // Skip fields that fail to convert
                }
            }

            return result;
        }

        /// <summary>
        /// Converts a SerializableValue to a usable object, properly handling arrays and all data types
        /// </summary>
        private object ConvertSerializableValue(SerializableValue value, dynamic field, AssetCollection? collection = null)
        {
            try
            {
                // Handle string values first (most common case)
                if (!string.IsNullOrEmpty(value.AsString))
                {
                    return value.AsString;
                }

                // Handle CValue which can be structures, assets, or arrays
                if (value.CValue != null)
                {
                    // Handle nested structures
                    if (value.CValue is SerializableStructure subStructure)
                    {
                        return ConvertStructureToDict(subStructure, collection, out _);
                    }

                    // Handle asset references
                    else if (value.CValue is IUnityAssetBase asset)
                    {
                        return new Dictionary<string, object>
                        {
                            ["type"] = asset.GetType().Name,
                            ["pathId"] = ExtractPathIdFromAsset(asset),
                            ["name"] = asset.ToString() ?? "unknown"
                        };
                    }

                    // Handle arrays and collections - THIS IS THE KEY FIX!
                    else if (value.CValue is System.Collections.IEnumerable enumerable &&
                             !(value.CValue is string)) // strings are enumerable but we don't want to treat them as arrays
                    {
                        var list = new List<object>();
                        foreach (var item in enumerable)
                        {
                            if (item is SerializableValue serializableItem)
                            {
                                list.Add(ConvertSerializableValue(serializableItem, field, collection));
                            }
                            else if (item != null)
                            {
                                list.Add(item.ToString() ?? "");
                            }
                        }
                        return list;
                    }

                    // Handle primitive values wrapped in CValue
                    return value.CValue;
                }

                // Handle numeric primitive values (PValue) with better type detection
                if (value.PValue != 0)
                {
                    // Try different numeric interpretations based on the field name
                    try
                    {
                        var fieldName = GetFieldName(field)?.ToLowerInvariant() ?? "";

                        // For boolean fields, interpret as boolean
                        if (fieldName.Contains("enabled") || fieldName.Contains("active") || fieldName.Contains("is") ||
                            fieldName.Contains("can") || fieldName.Contains("has") || fieldName.Contains("should") ||
                            fieldName.Contains("exhaust") || fieldName.Contains("destroy"))
                            return value.AsBoolean;

                        // For float/damage fields, use float representation
                        if (fieldName.Contains("damage") || fieldName.Contains("force") || fieldName.Contains("scale") ||
                            fieldName.Contains("speed") || fieldName.Contains("time") || fieldName.Contains("delay"))
                            return value.AsSingle;

                        // Default to integer for level, count, id fields
                        return value.AsInt32;
                    }
                    catch
                    {
                        return value.PValue;
                    }
                }

                // Handle specific typed values
                if (value.AsSingle != 0)
                    return value.AsSingle;
                if (value.AsDouble != 0)
                    return value.AsDouble;
                if (value.AsInt32 != 0)
                    return value.AsInt32;
                if (value.AsInt64 != 0)
                    return value.AsInt64;
                if (value.AsBoolean)
                    return true;

                return value.ToString() ?? "";
            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ö†Ô∏è Error converting SerializableValue: {ex.Message}");
                return value.ToString() ?? "";
            }
        }

        /// <summary>
        /// Extracts field name from field object (handles dynamic/reflection types)
        /// </summary>
        private string? GetFieldName(dynamic field)
        {
            try
            {
                // Handle dynamic field objects
                return field?.Name?.ToString();
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Resolves a sprite reference to actual sprite metadata using cross-bundle support
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ResolveSprite(IUnityAssetBase spriteRef, GameBundle gameBundle)
        {
            try
            {
                // Check for directly resolved sprite/texture references
                if (spriteRef is ISprite sprite)
                {
                    Logger.Debug($"‚úÖ Direct sprite reference resolved: {sprite.Name}");
                    return ExtractSpriteWithImprovedProcessing(sprite);
                }

                if (spriteRef is ITexture2D texture)
                {
                    Logger.Debug($"‚úÖ Direct texture reference resolved: {texture.Name}");
                    return ExtractTextureWithImprovedProcessing(texture);
                }

                // Handle AssetRipper-generated PPtr types (like PPtr_Object_5)
                // These types have a TryGetAsset method that resolves the actual referenced object
                var ptrType = spriteRef.GetType();
                var tryGetAssetMethod = ptrType.GetMethod("TryGetAsset");

                if (tryGetAssetMethod != null)
                {
                    try
                    {
                        // Call TryGetAsset to resolve the PPtr reference  
                        // Method signature: bool TryGetAsset(AssetCollection collection, out T? asset)
                        // We need to find the right collection - try all collections in the gameBundle
                        foreach (var candidateCollection in gameBundle.FetchAssetCollections())
                        {
                            var parameters = new object?[] { candidateCollection, null };
                            var collectionResult = tryGetAssetMethod.Invoke(spriteRef, parameters);

                            if (collectionResult is bool collectionSuccess && collectionSuccess && parameters[1] is IUnityObjectBase resolvedAsset)
                            {
                                if (resolvedAsset is ISprite resolvedSprite)
                                {
                                    Logger.Debug($"‚úÖ PPtr resolved to sprite: {resolvedSprite.Name}");
                                    return ExtractSpriteWithImprovedProcessing(resolvedSprite);
                                }
                                else if (resolvedAsset is ITexture2D resolvedTexture)
                                {
                                    Logger.Debug($"‚úÖ PPtr resolved to texture: {resolvedTexture.Name}");
                                    return ExtractTextureWithImprovedProcessing(resolvedTexture);
                                }
                                else
                                {
                                    Logger.Debug($"‚ö†Ô∏è PPtr resolved to unexpected type: {resolvedAsset.GetType().Name}");
                                    // Dump full properties of this asset to understand its structure
                                    DumpAssetPropertiesForAnalysis(resolvedAsset, $"PPtr_Resolved_{resolvedAsset.GetType().Name}");
                                }

                                // Successfully resolved, break out of collection loop
                                break;
                            }
                        }

                        Logger.Debug($"‚ùå PPtr resolution failed for {ptrType.Name} across all collections");
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ùå Error resolving PPtr {ptrType.Name}: {ex.Message}");
                    }
                }
                else
                {
                    Logger.Debug($"‚ùå Unrecognized sprite reference type: {ptrType.Name}");
                }

                return null;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error resolving sprite reference: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Resolves sprite references with forced sprite type (overrides automatic type detection)
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ResolveSprite(IUnityAssetBase spriteRef, GameBundle gameBundle, SpriteCacheManager.SpriteType forcedSpriteType)
        {
            try
            {
                // Check for directly resolved sprite/texture references
                if (spriteRef is ISprite sprite)
                {
                    Logger.Debug($"‚úÖ Direct sprite reference resolved: {sprite.Name} (forced type: {forcedSpriteType})");
                    return ExtractSpriteWithImprovedProcessing(sprite, forcedSpriteType);
                }

                if (spriteRef is ITexture2D texture)
                {
                    Logger.Debug($"‚úÖ Direct texture reference resolved: {texture.Name} (forced type: {forcedSpriteType})");
                    return ExtractTextureWithImprovedProcessing(texture, forcedSpriteType);
                }

                // Handle AssetRipper-generated PPtr types (like PPtr_Object_5)
                // These types have a TryGetAsset method that resolves the actual referenced object
                var ptrType = spriteRef.GetType();
                var tryGetAssetMethod = ptrType.GetMethod("TryGetAsset");

                if (tryGetAssetMethod != null)
                {
                    try
                    {
                        // Call TryGetAsset to resolve the PPtr reference  
                        // Method signature: bool TryGetAsset(AssetCollection collection, out T? asset)
                        // We need to find the right collection - try all collections in the gameBundle
                        foreach (var candidateCollection in gameBundle.FetchAssetCollections())
                        {
                            var parameters = new object?[] { candidateCollection, null };
                            var collectionResult = tryGetAssetMethod.Invoke(spriteRef, parameters);

                            if (collectionResult is bool collectionSuccess && collectionSuccess && parameters[1] is IUnityObjectBase resolvedAsset)
                            {
                                if (resolvedAsset is ISprite resolvedSprite)
                                {
                                    Logger.Debug($"‚úÖ PPtr resolved to sprite: {resolvedSprite.Name} (forced type: {forcedSpriteType})");
                                    return ExtractSpriteWithImprovedProcessing(resolvedSprite, forcedSpriteType);
                                }
                                else if (resolvedAsset is ITexture2D resolvedTexture)
                                {
                                    Logger.Debug($"‚úÖ PPtr resolved to texture: {resolvedTexture.Name} (forced type: {forcedSpriteType})");
                                    return ExtractTextureWithImprovedProcessing(resolvedTexture, forcedSpriteType);
                                }
                                else
                                {
                                    Logger.Debug($"‚ö†Ô∏è PPtr resolved to unexpected type: {resolvedAsset.GetType().Name} (forced type: {forcedSpriteType})");
                                    // Dump full properties of this asset to understand its structure
                                    DumpAssetPropertiesForAnalysis(resolvedAsset, $"PPtr_Resolved_{resolvedAsset.GetType().Name}");
                                }

                                // Successfully resolved, break out of collection loop
                                break;
                            }
                        }

                        Logger.Debug($"‚ùå PPtr resolution failed for {ptrType.Name} across all collections (forced type: {forcedSpriteType})");
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ùå Error resolving PPtr {ptrType.Name}: {ex.Message} (forced type: {forcedSpriteType})");
                    }
                }
                else
                {
                    Logger.Debug($"‚ùå Unrecognized sprite reference type: {ptrType.Name} (forced type: {forcedSpriteType})");
                }

                return null;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error resolving sprite reference: {ex.Message} (forced type: {forcedSpriteType})");
                return null;
            }
        }

        /// <summary>
        /// Extracts sprite metadata from a Sprite asset
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ExtractSprite(ISprite sprite)
        {
            try
            {
                var texture = sprite.TryGetTexture();
                if (texture == null) return null;

                var spriteId = GenerateSpriteId(sprite.Name ?? texture.Name);
                var spriteType = DetermineSpriteType(sprite.Name);

                var metadata = new SpriteCacheManager.SpriteMetadata
                {
                    Id = spriteId,
                    Name = sprite.Name ?? texture.Name,
                    Type = spriteType,
                    Width = texture.Width_C28,
                    Height = texture.Height_C28,
                    FrameWidth = (int)sprite.RD.TextureRect.Width,
                    FrameHeight = (int)sprite.RD.TextureRect.Height,
                    FrameX = (int)sprite.RD.TextureRect.X,
                    FrameY = (int)sprite.RD.TextureRect.Y,
                    FilePath = GetSpriteFilePath(spriteId, spriteType),
                    SourceBundle = ""
                };

                // Extract and save sprite image
                SaveSpriteImage(sprite, metadata.FilePath);

                return metadata;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting sprite {sprite.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Extracts sprite metadata from a Texture2D asset
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ExtractTexture(ITexture2D texture)
        {
            try
            {
                var spriteId = GenerateSpriteId(texture.Name);
                var spriteType = DetermineSpriteType(texture.Name);

                var metadata = new SpriteCacheManager.SpriteMetadata
                {
                    Id = spriteId,
                    Name = texture.Name,
                    Type = spriteType,
                    Width = texture.Width_C28,
                    Height = texture.Height_C28,
                    // For standalone textures processed as sprites, frame dimensions equal texture dimensions
                    FrameWidth = texture.Width_C28,
                    FrameHeight = texture.Height_C28,
                    FrameX = 0,
                    FrameY = 0,
                    FilePath = GetSpriteFilePath(spriteId, spriteType),
                    SourceBundle = ""
                };

                // Extract and save texture image
                SaveTextureImage(texture, metadata.FilePath);

                return metadata;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting texture {texture.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Saves sprite image to disk
        /// </summary>
        private void SaveSpriteImage(ISprite sprite, string filePath)
        {
            try
            {
                var cacheDir = PeglinDataExtractor.GetExtractionCacheDirectory();
                var fullPath = Path.Combine(cacheDir, filePath);
                var directory = Path.GetDirectoryName(fullPath);

                Logger.Debug($"üíæ Attempting to save sprite '{sprite.Name}' to: {fullPath}");

                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                var texture = sprite.TryGetTexture();
                if (texture != null)
                {
                    Logger.Debug($"‚úÖ Got texture for sprite '{sprite.Name}': {texture.Name} ({texture.Width_C28}x{texture.Height_C28})");
                    var success = ConvertTextureToPng(texture, fullPath);
                    if (success)
                    {
                        Logger.Debug($"üéâ Successfully saved sprite '{sprite.Name}'");
                    }
                    else
                    {
                        Logger.Warning($"‚ùå Failed to convert sprite '{sprite.Name}' to PNG");
                    }
                }
                else
                {
                    Logger.Warning($"‚ùå Failed to get texture for sprite '{sprite.Name}'");
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"‚ùå Error saving sprite image '{sprite.Name}': {ex.Message}");
            }
        }

        /// <summary>
        /// Saves texture image to disk
        /// </summary>
        private void SaveTextureImage(ITexture2D texture, string filePath)
        {
            try
            {
                var cacheDir = PeglinDataExtractor.GetExtractionCacheDirectory();
                var fullPath = Path.Combine(cacheDir, filePath);
                var directory = Path.GetDirectoryName(fullPath);

                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                ConvertTextureToPng(texture, fullPath);
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error saving texture image: {ex.Message}");
            }
        }

        // Entity detection methods
        private bool IsRelicData(Dictionary<string, object> data)
        {
            var relicFields = new[] { "locKey", "englishDisplayName", "effect", "globalRarity", "sprite" };
            var matchCount = relicFields.Count(field => data.ContainsKey(field));
            return matchCount >= 3;
        }

        private bool IsEnemyData(Dictionary<string, object> data)
        {
            // Use the same field detection logic as AssetRipperEnemyExtractor
            var enemyFields = new[]
            { 
                // From Enemy MonoBehaviour
                "CurrentHealth", "StartingHealth", "DamagePerMeleeAttack", "AttackRange", "enemyTypes",
                // From EnemyData ScriptableObject  
                "MaxHealth", "MaxHealthCruciball", "MeleeAttackDamage", "RangedAttackDamage", "location", "Type"
            };

            var matchCount = enemyFields.Count(field => data.ContainsKey(field));

            // Also check for specific patterns in values that indicate enemy data
            if (data.ContainsKey("LocKey") && data["LocKey"] is string locKey)
            {
                var enemyPatterns = new[] { "enemy", "boss", "slime", "ballista", "dragon", "demon", "sapper", "knight", "archer" };
                if (enemyPatterns.Any(pattern => locKey.ToLowerInvariant().Contains(pattern)))
                {
                    matchCount += 2; // Boost confidence for pattern match
                }
            }

            return matchCount >= 2;
        }

        private bool IsOrbData(Dictionary<string, object> data)
        {
            // Based on actual analysis: orb MonoBehaviour data is flattened, not nested in m_Structure
            // Look directly for orb-specific fields in the data

            // Debug logging to see what keys we have
            var keys = string.Join(", ", data.Keys.Take(20)); // Show first 20 keys
            Logger.Debug($"üîç IsOrbData checking data with keys: {keys}");

            // Check for orb-specific fields directly in the data (not in m_Structure)
            var requiredOrbFields = new[] { "locNameString", "locName", "DamagePerPeg", "CritDamagePerPeg", "Level" };
            var requiredFieldCount = requiredOrbFields.Count(field => data.ContainsKey(field));

            Logger.Debug($"üîç Required orb fields found: {requiredFieldCount}/5 - {string.Join(", ", requiredOrbFields.Where(field => data.ContainsKey(field)))}");

            // Must have at least 3 of the 5 required orb fields
            if (requiredFieldCount < 3)
            {
                Logger.Debug($"üîç Not enough required orb fields ({requiredFieldCount} < 3)");
                return false;
            }

            // If we have 4+ required fields, it's definitely an orb (like doctorb)
            if (requiredFieldCount >= 4)
            {
                Logger.Debug($"üîç Strong match: {requiredFieldCount}/5 required orb fields found - definitely an orb!");
                return true;
            }

            // For 3 required fields, check for additional evidence
            // Check for attack-type specific fields that distinguish orb types
            var attackTypeFields = new[] { "shotPrefab", "_shotPrefab", "_thunderPrefab", "_criticalShotPrefab", "_criticalThunderPrefab", "targetColumn", "verticalAttack", "targetingType" };
            var hasAttackTypeFields = attackTypeFields.Any(field => data.ContainsKey(field));

            // Check for MonoBehaviour script references that identify orb component types
            var hasScriptRef = data.ContainsKey("m_Script");

            Logger.Debug($"üîç Attack type fields: {hasAttackTypeFields}, Script ref: {hasScriptRef}");

            var isOrb = requiredFieldCount >= 3 && (hasAttackTypeFields || hasScriptRef);
            Logger.Debug($"üîç IsOrb result: {isOrb} (required fields: {requiredFieldCount >= 3}, type indicators: {hasAttackTypeFields || hasScriptRef})");

            // Must have required fields and either be a strong match or have attack-type indicators
            return isOrb;
        }

        private bool IsPachinkoBallData(Dictionary<string, object> data)
        {
            // PachinkoBall MonoBehaviours have physics/rendering fields but not orb data fields
            var pachinkoBallFields = new[] { "_renderer", "FireForce", "GravityScale", "MaxBounceCount", "MultiballForceMod" };
            var pachinkoBallCount = pachinkoBallFields.Count(field => data.ContainsKey(field));

            // Must have _renderer field and at least 2 other PachinkoBall-specific fields
            return data.ContainsKey("_renderer") && pachinkoBallCount >= 3;
        }

        private static bool IsLocalizationParamsManager(Dictionary<string, object> data)
        {
            // LocalizationParamsManager components have _Params array and _IsGlobalManager field
            return data.ContainsKey("_Params") && data.ContainsKey("_IsGlobalManager");
        }

        // Entity extraction methods
        private RelicData? ExtractRelic(string assetName, Dictionary<string, object> data, Dictionary<string, string>? localizationParams = null)
        {
            try
            {
                var relic = new RelicData
                {
                    RawData = data,
                    Id = CleanEntityId(assetName ?? "unknown")
                };

                if (data.TryGetValue("locKey", out var locKey))
                {
                    string nameKey = $"Relics/{locKey}_name";
                    bool hasDescMod = data.TryGetValue("descMod", out var descMod);
                    string descKey = $"Relics/{locKey}_desc{descMod?.ToString() ?? ""}";
                    relic.Name = localizationService.GetTranslation(nameKey) ?? assetName ?? "Unknown Relic";
                    relic.Description = localizationService.GetTranslation(descKey) ?? "Unknown Relic Description";
                }
                if (string.IsNullOrEmpty(relic.Name) || string.IsNullOrEmpty(relic.Description))
                {
                    if (data.TryGetValue("englishDisplayName", out var name))
                    {
                        relic.Name = name?.ToString() ?? assetName ?? "Unknown Relic";
                    }
                    else
                    {
                        relic.Name = assetName ?? "Unknown Relic";
                    }
                    if (data.TryGetValue("englishDescription", out var desc))
                    {
                        relic.Description = desc?.ToString() ?? "";
                    }
                }



                if (data.TryGetValue("effect", out var effect))
                {
                    relic.Effect = effect?.ToString() ?? "";
                }

                if (data.TryGetValue("globalRarity", out var rarity) && int.TryParse(rarity?.ToString(), out var rarityInt))
                {
                    relic.RarityValue = rarityInt;
                    relic.Rarity = _enumExtractor.GetEnumName("RelicRarity", rarityInt);
                }

                // Apply token resolution if we have localization parameters
                if (localizationParams != null && localizationParams.Count > 0)
                {
                    Logger.Debug($"üî§ Applying token resolution to relic {relic.Name} with {localizationParams.Count} parameters: {string.Join(", ", localizationParams.Select(p => $"{p.Key}={p.Value}"))}");
                    
                    // Resolve tokens in description
                    if (!string.IsNullOrEmpty(relic.Description))
                    {
                        var resolvedDescription = ResolveTokens(relic.Description, localizationParams);
                        if (resolvedDescription != relic.Description)
                        {
                            Logger.Debug($"üî§ Resolved relic description: '{relic.Description}' -> '{resolvedDescription}'");
                            relic.Description = resolvedDescription;
                        }
                    }
                    
                    // Resolve tokens in effect field if it's a string (some relics might have textual effects)
                    if (!string.IsNullOrEmpty(relic.Effect))
                    {
                        var resolvedEffect = ResolveTokens(relic.Effect, localizationParams);
                        if (resolvedEffect != relic.Effect)
                        {
                            Logger.Debug($"üî§ Resolved relic effect: '{relic.Effect}' -> '{resolvedEffect}'");
                            relic.Effect = resolvedEffect;
                        }
                    }
                }
                else if (localizationParams != null)
                {
                    Logger.Debug($"üî§ No parameters available for token resolution in relic {relic.Name}");
                }

                return relic;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting relic data: {ex.Message}");
                return null;
            }
        }

        private EnemyData? ExtractEnemy(string assetName, Dictionary<string, object> data)
        {
            try
            {
                var enemy = new EnemyData
                {
                    RawData = data,
                    Id = CleanEntityId(assetName ?? "unknown")
                };

                // Try different name fields
                if (data.TryGetValue("EnglishDisplayName", out var displayName))
                {
                    enemy.Name = displayName?.ToString() ?? assetName;
                }
                else if (data.TryGetValue("LocKey", out var locKey))
                {
                    enemy.Name = locKey?.ToString() ?? assetName;
                }
                else if (data.TryGetValue("enemyName", out var enemyName))
                {
                    enemy.Name = enemyName?.ToString() ?? assetName;
                }

                // Try different health fields
                if (data.TryGetValue("MaxHealth", out var maxHealth) && float.TryParse(maxHealth?.ToString(), out var maxHealthFloat))
                {
                    enemy.MaxHealth = maxHealthFloat;
                }
                else if (data.TryGetValue("StartingHealth", out var startingHealth) && float.TryParse(startingHealth?.ToString(), out var startingHealthFloat))
                {
                    enemy.MaxHealth = startingHealthFloat;
                }

                // Try different attack damage fields
                if (data.TryGetValue("MeleeAttackDamage", out var meleeAttack) && float.TryParse(meleeAttack?.ToString(), out var meleeAttackFloat))
                {
                    enemy.MeleeAttackDamage = meleeAttackFloat;
                }
                else if (data.TryGetValue("DamagePerMeleeAttack", out var damagePerMelee) && float.TryParse(damagePerMelee?.ToString(), out var damagePerMeleeFloat))
                {
                    enemy.MeleeAttackDamage = damagePerMeleeFloat;
                }

                return enemy;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting enemy data: {ex.Message}");
                return null;
            }
        }

        public OrbData? ExtractOrb(string assetName, Dictionary<string, object> data)
        {
            try
            {
                // Extract orb data directly from the data dictionary (not from m_Structure)
                var orb = new OrbData
                {
                    Id = CleanEntityId(assetName ?? "unknown"),
                    RawData = data
                };

                // Extract localization key from locNameString
                if (data.TryGetValue("locNameString", out var locNameString))
                {
                    orb.LocKey = locNameString?.ToString();
                }

                // Prefer localization key-based name over pre-translated fields
                if (!string.IsNullOrEmpty(orb.LocKey))
                {
                    try
                    {

                        var nameKey = $"{orb.LocKey}_name";
                        var localizedName = localizationService.GetTranslation($"Orbs/{nameKey}");
                        if (!string.IsNullOrWhiteSpace(localizedName))
                        {
                            orb.Name = localizedName;
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ö†Ô∏è Failed to get localized name for orb {assetName} using LocKey {orb.LocKey}: {ex.Message}");
                    }
                }

                // Fallback to pre-translated locName if localization key failed
                if (string.IsNullOrWhiteSpace(orb.Name) && data.TryGetValue("locName", out var locName))
                {
                    orb.Name = locName?.ToString();
                }

                // Final fallback to formatted asset name
                if (string.IsNullOrWhiteSpace(orb.Name))
                {
                    orb.Name = assetName ?? "Unknown Orb";
                }

                // Look for locDescStrings array and translate to DescriptionStrings
                IEnumerable<object>? locDescStringsArray = null;

                // Try various nested paths for locDescStrings
                if (data.TryGetValue("locDescStrings", out var directLocDescStrings) &&
                    directLocDescStrings is IEnumerable<object> directArray)
                {
                    locDescStringsArray = directArray;
                }
                else if (data.TryGetValue("ComponentData", out var componentDataObj) &&
                    componentDataObj is Dictionary<string, object> componentData &&
                    componentData.TryGetValue("OrbComponent", out var orbComponentObj) &&
                    orbComponentObj is Dictionary<string, object> orbComponent &&
                    orbComponent.TryGetValue("locDescStrings", out var nestedLocDescStrings) &&
                    nestedLocDescStrings is IEnumerable<object> nestedArray)
                {
                    locDescStringsArray = nestedArray;
                }
                else if (data.TryGetValue("RawData", out var rawDataObj) &&
                    rawDataObj is Dictionary<string, object> rawData &&
                    rawData.TryGetValue("ComponentData", out var rawComponentDataObj) &&
                    rawComponentDataObj is Dictionary<string, object> rawComponentData &&
                    rawComponentData.TryGetValue("OrbComponent", out var rawOrbComponentObj) &&
                    rawOrbComponentObj is Dictionary<string, object> rawOrbComponent &&
                    rawOrbComponent.TryGetValue("locDescStrings", out var rawLocDescStrings) &&
                    rawLocDescStrings is IEnumerable<object> rawArray)
                {
                    locDescStringsArray = rawArray;
                }

                // Translate locDescStrings to DescriptionStrings for frontend rendering
                if (locDescStringsArray != null)
                {
                    var locDescStringsList = locDescStringsArray.Select(x => x?.ToString()).Where(x => !string.IsNullOrEmpty(x)).Cast<string>().ToList();

                    if (locDescStringsList.Count > 0)
                    {
                        try
                        {

                            var translatedStrings = new List<string>();
                            foreach (var descKey in locDescStringsList)
                            {
                                var translation = localizationService.GetTranslation($"Orbs/{descKey}");
                                if (!string.IsNullOrWhiteSpace(translation))
                                {
                                    translatedStrings.Add(translation);
                                }
                            }
                            orb.DescriptionStrings = translatedStrings;
                        }
                        catch (Exception ex)
                        {
                            Logger.Debug($"‚ö†Ô∏è Failed to get localized descriptions from locDescStrings for orb {orb.Name}: {ex.Message}");
                        }
                    }
                }

                // Extract damage values directly from data
                if (data.TryGetValue("DamagePerPeg", out var damagePerPegValue))
                {
                    // Handle cases where value is already numeric or needs parsing
                    if (damagePerPegValue is float floatDamage)
                    {
                        orb.DamagePerPeg = floatDamage;
                    }
                    else if (damagePerPegValue is double doubleDamage)
                    {
                        orb.DamagePerPeg = (float)doubleDamage;
                    }
                    else if (damagePerPegValue is int intDamage)
                    {
                        orb.DamagePerPeg = intDamage;
                    }
                    else if (float.TryParse(damagePerPegValue?.ToString(), out var parsedDamage))
                    {
                        orb.DamagePerPeg = parsedDamage;
                    }
                    else
                    {
                        // Handle SerializableValue objects from Unity serialization
                        var damageStr = damagePerPegValue?.ToString() ?? "";
                        if (damageStr.Contains("PValue ="))
                        {
                            // Extract PValue using regex from the string representation
                            var match = System.Text.RegularExpressions.Regex.Match(damageStr, @"PValue = ([^,]+)");
                            if (match.Success && float.TryParse(match.Groups[1].Value.Trim(), out var extractedDamage))
                            {
                                orb.DamagePerPeg = extractedDamage;
                                Logger.Debug($"Extracted PValue {extractedDamage} from SerializableValue string for {assetName}");
                            }
                        }
                    }
                }

                if (data.TryGetValue("CritDamagePerPeg", out var critDamagePerPegValue))
                {
                    // Handle cases where value is already numeric or needs parsing
                    if (critDamagePerPegValue is float floatCrit)
                    {
                        orb.CritDamagePerPeg = floatCrit;
                    }
                    else if (critDamagePerPegValue is double doubleCrit)
                    {
                        orb.CritDamagePerPeg = (float)doubleCrit;
                    }
                    else if (critDamagePerPegValue is int intCrit)
                    {
                        orb.CritDamagePerPeg = intCrit;
                    }
                    else if (float.TryParse(critDamagePerPegValue?.ToString(), out var parsedCrit))
                    {
                        orb.CritDamagePerPeg = parsedCrit;
                    }
                }

                // Extract level from data (store in RawData for now since OrbData doesn't have Level property)
                if (data.TryGetValue("Level", out var levelValue))
                {
                    // Handle cases where value is already numeric or needs parsing
                    int? extractedLevel = null;
                    if (levelValue is int intLevel)
                    {
                        extractedLevel = intLevel;
                    }
                    else if (levelValue is long longLevel)
                    {
                        extractedLevel = (int)longLevel;
                    }
                    else if (int.TryParse(levelValue?.ToString(), out var parsedLevel))
                    {
                        extractedLevel = parsedLevel;
                    }

                    if (extractedLevel.HasValue)
                    {
                        // Store level info in RawData for future processing
                        if (orb.RawData == null) orb.RawData = new Dictionary<string, object>();
                        orb.RawData["Level"] = extractedLevel.Value;
                        orb.Level = extractedLevel.Value;
                    }
                }

                // Determine orb type based on available fields  
                orb.OrbType = DetermineOrbTypeFromData(assetName, data);

                // Set default rarity (orbs typically don't have explicit rarity like relics)
                orb.RarityValue = 1;
                orb.Rarity = "COMMON";

                // Try to resolve sprite references from prefab fields
                ResolvePrefabSprites(orb, data);

                return orb;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting orb data: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Tries to resolve sprites from orb prefab references like _shotPrefab, _criticalShotPrefab, etc.
        /// </summary>
        private void ResolvePrefabSprites(OrbData orb, Dictionary<string, object> data)
        {
            try
            {
                // List of prefab fields that might contain sprites
                var prefabFields = new[] { "_shotPrefab", "_criticalShotPrefab", "_thunderPrefab", "_criticalThunderPrefab" };

                foreach (var fieldName in prefabFields)
                {
                    if (data.TryGetValue(fieldName, out var prefabRef) &&
                        prefabRef is Dictionary<string, object> prefabDict)
                    {
                        Logger.Debug($"üîç Found prefab reference {fieldName} in orb {orb.Name}");

                        // Try to resolve this prefab reference and extract sprites from it
                        // Store the prefab reference info for now - actual resolution would need 
                        // access to the AssetCollection to call TryGetAsset
                        if (orb.RawData == null) orb.RawData = new Dictionary<string, object>();

                        // Extract PathID if available for later correlation
                        if (prefabDict.TryGetValue("pathId", out var pathIdObj))
                        {
                            orb.RawData[$"{fieldName}_PathID"] = pathIdObj;
                            Logger.Debug($"üìã Stored PathID for {fieldName}: {pathIdObj}");
                        }
                    }
                }

                // Also check for direct sprite field references that were found in debug logs
                var spriteFields = new[] { "pierceSprite", "originalSprite", "dullSprite" };

                foreach (var fieldName in spriteFields)
                {
                    if (data.TryGetValue(fieldName, out var spriteRef) &&
                        spriteRef is Dictionary<string, object> spriteDict)
                    {
                        Logger.Debug($"üé® Found direct sprite reference {fieldName} in orb {orb.Name}");

                        if (spriteDict.TryGetValue("pathId", out var pathIdObj))
                        {
                            if (orb.RawData == null) orb.RawData = new Dictionary<string, object>();
                            orb.RawData[$"{fieldName}_PathID"] = pathIdObj;
                            Logger.Debug($"üéØ Stored sprite PathID for {fieldName}: {pathIdObj}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ö†Ô∏è Error resolving prefab sprites for orb {orb.Name}: {ex.Message}");
            }
        }

        private string DetermineOrbTypeFromData(string assetName, Dictionary<string, object> data)
        {
            var lowerName = assetName.ToLowerInvariant();

            // Check for specific orb type patterns in name
            if (lowerName.Contains("heal") || lowerName.Contains("support"))
                return "UTILITY";
            if (lowerName.Contains("special") || lowerName.Contains("unique"))
                return "SPECIAL";
            if (lowerName.Contains("attack") || lowerName.Contains("damage") || data.ContainsKey("DamagePerPeg"))
                return "ATTACK";

            return "ATTACK"; // Default to attack type
        }

        private OrbData? ExtractOrbFromStructure(string assetName, Dictionary<string, object> componentData, Dictionary<string, object> structure)
        {
            try
            {
                var orb = new OrbData
                {
                    RawData = componentData,
                    Id = CleanEntityId(assetName ?? "unknown")
                };

                // Extract localization key from locNameString
                if (structure.TryGetValue("locNameString", out var locNameString))
                {
                    orb.LocKey = locNameString?.ToString();
                }

                // Prefer localization key-based name over pre-translated fields
                if (!string.IsNullOrEmpty(orb.LocKey))
                {
                    try
                    {
                        var nameKey = $"{orb.LocKey}_name";
                        var localizedName = localizationService.GetTranslation($"Orbs/{nameKey}");
                        if (!string.IsNullOrWhiteSpace(localizedName))
                        {
                            orb.Name = localizedName;
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ö†Ô∏è Failed to get localized name for orb {assetName} using LocKey {orb.LocKey}: {ex.Message}");
                    }
                }

                // Fallback to pre-translated locName if localization key failed
                if (string.IsNullOrWhiteSpace(orb.Name) && structure.TryGetValue("locName", out var locName))
                {
                    orb.Name = locName?.ToString();
                }

                // Final fallback to asset name
                if (string.IsNullOrWhiteSpace(orb.Name))
                {
                    orb.Name = assetName ?? "Unknown Orb";
                }

                // Prefer localization key-based description over pre-translated fields
                if (!string.IsNullOrEmpty(orb.LocKey))
                {
                    try
                    {
                        var localizedDesc = localizationService.GetTranslation($"Orbs/{orb.LocKey}");
                        if (!string.IsNullOrWhiteSpace(localizedDesc))
                        {
                            // orb.Description = localizedDesc; // Removed: use DescriptionStrings instead
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ö†Ô∏è Failed to get localized description for orb {assetName} using LocKey {orb.LocKey}: {ex.Message}");
                    }
                }

                // Fallback to pre-translated locDescription if localization key failed
                if (string.IsNullOrWhiteSpace(orb.Description))
                {
                    if (structure.TryGetValue("locDescription", out var locDescription))
                    {
                        // orb.Description = locDescription?.ToString() ?? ""; // Removed: use DescriptionStrings instead
                    }
                    else if (componentData.TryGetValue("locDescription", out var componentLocDescription))
                    {
                        // orb.Description = componentLocDescription?.ToString() ?? ""; // Removed: use DescriptionStrings instead
                    }
                    else if (componentData.TryGetValue("ComponentData", out var nestedComponentDataObj) &&
                        nestedComponentDataObj is Dictionary<string, object> nestedComponentData &&
                        nestedComponentData.TryGetValue("OrbComponent", out var orbComponentObj) &&
                        orbComponentObj is Dictionary<string, object> orbComponent &&
                        orbComponent.TryGetValue("locDescription", out var nestedLocDescription))
                    {
                        // orb.Description = nestedLocDescription?.ToString() ?? ""; // Removed: use DescriptionStrings instead
                    }
                }

                // Look for locDescStrings array and translate to DescriptionStrings
                List<string>? locDescStrings = null;

                if (structure.TryGetValue("locDescStrings", out var structureLocDescStrings) &&
                    structureLocDescStrings is IEnumerable<object> structureArray)
                {
                    locDescStrings = structureArray.Select(x => x?.ToString()).Where(x => !string.IsNullOrEmpty(x)).Cast<string>().ToList();
                }
                else if (componentData.TryGetValue("locDescStrings", out var componentLocDescStrings) &&
                    componentLocDescStrings is IEnumerable<object> componentArray)
                {
                    locDescStrings = componentArray.Select(x => x?.ToString()).Where(x => !string.IsNullOrEmpty(x)).Cast<string>().ToList();
                }
                else if (componentData.TryGetValue("ComponentData", out var nestedComponentDataObj) &&
                    nestedComponentDataObj is Dictionary<string, object> nestedComponentData &&
                    nestedComponentData.TryGetValue("OrbComponent", out var orbComponentObj) &&
                    orbComponentObj is Dictionary<string, object> orbComponent &&
                    orbComponent.TryGetValue("locDescStrings", out var nestedLocDescStrings) &&
                    nestedLocDescStrings is IEnumerable<object> nestedArray)
                {
                    locDescStrings = nestedArray.Select(x => x?.ToString()).Where(x => !string.IsNullOrEmpty(x)).Cast<string>().ToList();
                }
                else if (componentData.TryGetValue("RawData", out var rawDataObj) &&
                    rawDataObj is Dictionary<string, object> rawData &&
                    rawData.TryGetValue("ComponentData", out var rawComponentDataObj) &&
                    rawComponentDataObj is Dictionary<string, object> rawComponentData &&
                    rawComponentData.TryGetValue("OrbComponent", out var rawOrbComponentObj) &&
                    rawOrbComponentObj is Dictionary<string, object> rawOrbComponent &&
                    rawOrbComponent.TryGetValue("locDescStrings", out var rawLocDescStrings) &&
                    rawLocDescStrings is IEnumerable<object> rawArray)
                {
                    locDescStrings = rawArray.Select(x => x?.ToString()).Where(x => !string.IsNullOrEmpty(x)).Cast<string>().ToList();
                }

                // Translate locDescStrings to DescriptionStrings for frontend rendering
                if (locDescStrings != null && locDescStrings.Count > 0)
                {
                    Logger.Debug($"üîç Found {locDescStrings.Count} locDescStrings for orb {orb.Name}: [{string.Join(", ", locDescStrings)}]");
                    try
                    {
                        var translatedStrings = new List<string>();
                        foreach (var descKey in locDescStrings)
                        {
                            var translation = localizationService.GetTranslation($"Orbs/{descKey}");
                            Logger.Debug($"üî§ Translation for '{descKey}': '{translation}'");
                            if (!string.IsNullOrWhiteSpace(translation))
                            {
                                translatedStrings.Add(translation);
                            }
                        }
                        orb.DescriptionStrings = translatedStrings;
                        Logger.Debug($"‚úÖ Translated {translatedStrings.Count} description strings for orb {orb.Name}");
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ö†Ô∏è Failed to get localized descriptions from locDescStrings for orb {orb.Name}: {ex.Message}");
                    }
                }
                else
                {
                    Logger.Debug($"‚è≠Ô∏è No locDescStrings found for orb {orb.Name}");
                }

                // Handle single LocKey for Description field if no direct description exists  
                if (string.IsNullOrWhiteSpace(orb.Description) && !string.IsNullOrWhiteSpace(orb.LocKey))
                {
                    try
                    {
                        var localizedDescription = localizationService.GetTranslation($"Orbs/{orb.LocKey}");
                        if (!string.IsNullOrWhiteSpace(localizedDescription))
                        {
                            // orb.Description = localizedDescription; // Removed: use DescriptionStrings instead
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ö†Ô∏è Failed to get localized description for orb {orb.Name} (LocKey: {orb.LocKey}): {ex.Message}");
                    }
                }

                // Extract damage values directly from structure
                if (structure.TryGetValue("DamagePerPeg", out var damagePerPeg) &&
                    float.TryParse(damagePerPeg?.ToString(), out var damage))
                {
                    orb.DamagePerPeg = damage;
                }

                if (structure.TryGetValue("CritDamagePerPeg", out var critDamagePerPeg) &&
                    float.TryParse(critDamagePerPeg?.ToString(), out var critDamage))
                {
                    orb.CritDamagePerPeg = critDamage;
                }

                // Derive base ID from locNameString (clean base name without level)  
                // TODO: Enable when BaseId property is available
                // if (!string.IsNullOrWhiteSpace(orb.LocKey))
                // {
                //     orb.BaseId = orb.LocKey.ToLowerInvariant().Replace(" ", "_");
                // }
                // else
                // {
                //     orb.BaseId = CleanEntityId(assetName ?? "unknown");
                // }

                // Simple orb type detection based on damage values
                if (orb.DamagePerPeg.HasValue && orb.DamagePerPeg.Value > 0)
                {
                    orb.OrbType = "ATTACK";
                }
                else
                {
                    orb.OrbType = "UTILITY";
                }

                // Extract rarity (orbs typically don't have rarity tiers)
                orb.RarityValue = 1; // Default to COMMON
                orb.Rarity = "COMMON";

                return orb;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting orb from structure: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Processes a GameObject to check if it represents an orb and extract orb data
        /// </summary>
        private void ProcessGameObjectForOrbs(IGameObject gameObject, Dictionary<long, IMonoBehaviour> componentMap,
            UnifiedExtractionResult result, Dictionary<string, IUnityAssetBase> orbSpriteRefs, AssetCollection collection)
        {
            try
            {

                var gameObjectData = new GameObjectData
                {
                    Id = CleanEntityId(gameObject.Name),
                    Name = gameObject.Name,
                    PathID = gameObject.PathID
                };

                // Extract components from the GameObject
                ExtractGameObjectComponents(gameObject, componentMap, gameObjectData, collection);


                Logger.Debug($"üîç Checking if GameObject {gameObjectData.Name} is an orb. Components: {string.Join(", ", gameObjectData.Components.Select(c => c.Type))}");
                if (IsOrbGameObject(gameObjectData))
                {
                    Logger.Debug($"‚úÖ GameObject {gameObjectData.Name} identified as orb");
                    // Convert GameObject data to OrbData
                    var orbData = ConvertGameObjectToOrbData(gameObjectData);
                    if (orbData != null && !string.IsNullOrEmpty(orbData.Id))
                    {
                        // Store orb with its natural ID, but track GameObject PathID for sprite correlation
                        result.Orbs[orbData.Id] = orbData;

                        // Try to find sprite reference (look for sprite components or references)
                        var spriteReference = FindGameObjectSpriteReference(gameObject, componentMap, collection);
                        if (spriteReference != null)
                        {
                            orbSpriteRefs[orbData.Id] = spriteReference;
                            Logger.Debug($"‚ö™ Found sprite reference for orb {orbData.Id}: {spriteReference.GetType().Name}");
                        }

                        // Check if we have a PachinkoBall sprite for this GameObject
                        var gameObjectKey = $"gameObject_{gameObject.PathID}";
                        if (orbSpriteRefs.ContainsKey(gameObjectKey))
                        {
                            // Correlate the PachinkoBall sprite with this orb
                            var pachinkoBallSprite = orbSpriteRefs[gameObjectKey];
                            if (pachinkoBallSprite is IUnityObjectBase spriteObj)
                            {
                                orbData.CorrelatedSpriteId = $"sprite_{spriteObj.PathID}";
                                orbData.CorrelationMethod = "PachinkoBall";
                                orbData.CorrelationConfidence = 1.0f;
                                Logger.Debug($"üéØ Correlated orb {orbData.Id} with PachinkoBall sprite {orbData.CorrelatedSpriteId}");
                            }
                            else
                            {
                                Logger.Debug($"‚ùå PachinkoBall sprite is not IUnityObjectBase: {pachinkoBallSprite.GetType().Name}");
                            }
                        }
                        else
                        {
                            Logger.Debug($"‚ùå No PachinkoBall sprite found for GameObject {gameObjectKey}");
                        }

                        Logger.Debug($"Found orb GameObject: {orbData.Id} - {orbData.Name}");
                    }
                    else
                    {
                        Logger.Debug($"‚ùå Failed to convert GameObject {gameObjectData.Name} to OrbData");
                    }
                }
                else
                {
                    Logger.Debug($"‚ùå GameObject {gameObjectData.Name} rejected as orb");
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error processing GameObject for orbs: {ex.Message}");
            }
        }

        /// <summary>
        /// Extracts components from a GameObject
        /// </summary>
        private void ExtractGameObjectComponents(IGameObject gameObject, Dictionary<long, IMonoBehaviour> componentMap,
            GameObjectData gameObjectData, AssetCollection collection)
        {
            try
            {
                // Extract actual component data from the GameObject's component references
                var gameObjectInfo = new Dictionary<string, object>
                {
                    ["Name"] = gameObject.Name,
                    ["PathID"] = gameObject.PathID
                };

                // Fetch all components from the GameObject
                var components = gameObject.FetchComponents();
                var extractedComponentData = new Dictionary<string, object>();
                var orbComponentsFound = new List<Dictionary<string, object>>();
                Dictionary<string, string>? localizationParams = null;

                foreach (var componentPtr in components)
                {
                    try
                    {
                        // Try to resolve the component reference
                        var component = componentPtr.TryGetAsset(collection);
                        if (component != null)
                        {
                            // Handle MonoBehaviour components (orb data, etc.)
                            if (component is IMonoBehaviour monoBehaviour)
                            {

                                // Load the structure data from the MonoBehaviour
                                var structure = monoBehaviour.LoadStructure();
                                if (structure != null)
                                {
                                    // Check if this might be a LocalizationParamsManager before conversion
                                    bool isLocalizationManager = false;
                                    try
                                    {
                                        // Try to access the raw structure to see if we can get better parameter data
                                        foreach (var field in structure.Type.Fields)
                                        {
                                            if (field.Name == "_Params" && structure.TryGetField(field.Name, out var paramsValue))
                                            {
                                                Logger.Debug($"üîç Found raw _Params field in {gameObject.Name}, type: {field.Type?.Name ?? "unknown"}");
                                                Logger.Debug($"üîç Raw _Params value type: {paramsValue.GetType().Name}");
                                                Logger.Debug($"üîç Raw _Params CValue type: {paramsValue.CValue?.GetType().Name ?? "null"}");
                                                
                                                // Try to access the raw array data
                                                if (paramsValue.CValue != null)
                                                {
                                                    Logger.Debug($"üîç Raw _Params CValue: {paramsValue.CValue}");
                                                    isLocalizationManager = true;
                                                }
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        Logger.Debug($"Error accessing raw structure: {ex.Message}");
                                    }

                                    // Convert to dictionary for processing
                                    IUnityAssetBase? spriteRef = null;
                                    var componentData = ConvertStructureToDict(structure, collection, out spriteRef);

                                    // Check if this is LocalizationParamsManager
                                    if (IsLocalizationParamsManager(componentData))
                                    {
                                        Logger.Debug($"‚úÖ Found LocalizationParamsManager in GameObject {gameObject.Name}");
                                        
                                        // Try the raw structure approach if we detected it earlier
                                        Dictionary<string, string>? extractedParams = null;
                                        if (isLocalizationManager)
                                        {
                                            extractedParams = ExtractLocalizationParamsFromRawStructure(structure);
                                        }
                                        
                                        // Fallback to the converted data approach
                                        if (extractedParams == null)
                                        {
                                            extractedParams = ExtractLocalizationParams(componentData);
                                        }
                                        
                                        if (extractedParams != null && extractedParams.Count > 0)
                                        {
                                            localizationParams = extractedParams;
                                            Logger.Debug($"üî§ Extracted {extractedParams.Count} localization parameters: {string.Join(", ", extractedParams.Keys)}");
                                            
                                            // Store localization parameters in ComponentData for later use
                                            extractedComponentData["LocalizationParams"] = localizationParams;
                                            
                                            // Store global relic parameters for later use with all relics
                                            if (gameObject.Name.ToString().Contains("relic", StringComparison.OrdinalIgnoreCase))
                                            {
                                                Logger.Debug($"üî§ Storing global relic parameters from GameObject {gameObject.Name}: {extractedParams.Count} parameters");
                                                
                                                // Accumulate parameters instead of overwriting
                                                if (_globalRelicParameters == null)
                                                {
                                                    _globalRelicParameters = new Dictionary<string, string>(extractedParams);
                                                }
                                                else
                                                {
                                                    foreach (var kvp in extractedParams)
                                                    {
                                                        _globalRelicParameters[kvp.Key] = kvp.Value;
                                                    }
                                                    Logger.Debug($"üî§ Total accumulated global relic parameters: {_globalRelicParameters.Count}");
                                                }
                                            }
                                        }
                                        else
                                        {
                                            Logger.Debug($"‚ùå LocalizationParamsManager found but no parameters extracted from GameObject {gameObject.Name}");
                                        }
                                    }
                                    // Check if this is orb data
                                    else if (IsOrbData(componentData))
                                    {
                                        Logger.Debug($"‚úÖ Found orb MonoBehaviour in GameObject {gameObject.Name}");

                                        // Collect all orb components for aggregation
                                        orbComponentsFound.Add(componentData);
                                    }

                                    // Store component info even if not orb data
                                    var componentType = monoBehaviour.GetType().Name;
                                    gameObjectData.Components.Add(new ComponentData
                                    {
                                        Type = componentType,
                                        Properties = componentData
                                    });
                                }
                            }
                            // Handle Sprite components
                            else if (component is ISprite sprite)
                            {
                                Logger.Debug($"üé® Found Sprite component in GameObject {gameObject.Name}: {sprite.Name}");

                                var spriteData = new Dictionary<string, object>
                                {
                                    ["Name"] = sprite.Name,
                                    ["PathID"] = sprite.PathID,
                                    ["Type"] = "Sprite"
                                };

                                // Try to get the texture associated with this sprite
                                try
                                {
                                    var texture = sprite.TryGetTexture();
                                    if (texture != null)
                                    {
                                        spriteData["TextureName"] = texture.Name;
                                        spriteData["TexturePathID"] = texture.PathID;
                                        Logger.Debug($"üñºÔ∏è Sprite {sprite.Name} references texture: {texture.Name} (PathID: {texture.PathID})");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Logger.Debug($"Could not resolve texture for sprite {sprite.Name}: {ex.Message}");
                                }

                                // Store sprite data for correlation
                                extractedComponentData["SpriteComponent"] = spriteData;

                                gameObjectData.Components.Add(new ComponentData
                                {
                                    Type = "Sprite",
                                    Name = sprite.Name,
                                    PathID = sprite.PathID,
                                    Properties = spriteData
                                });
                            }
                            // Handle Texture2D components
                            else if (component is ITexture2D texture2D)
                            {
                                Logger.Debug($"üñºÔ∏è Found Texture2D component in GameObject {gameObject.Name}: {texture2D.Name}");

                                var textureData = new Dictionary<string, object>
                                {
                                    ["Name"] = texture2D.Name,
                                    ["PathID"] = texture2D.PathID,
                                    ["Type"] = "Texture2D"
                                };

                                // Store texture data for correlation
                                extractedComponentData["TextureComponent"] = textureData;

                                gameObjectData.Components.Add(new ComponentData
                                {
                                    Type = "Texture2D",
                                    Name = texture2D.Name,
                                    PathID = texture2D.PathID,
                                    Properties = textureData
                                });
                            }
                            else
                            {
                                // Handle other component types
                                var componentType = component.GetType().Name;
                                Logger.Debug($"üîß Found component type {componentType} in GameObject {gameObject.Name}");

                                gameObjectData.Components.Add(new ComponentData
                                {
                                    Type = componentType,
                                    Name = component.ToString() ?? componentType,
                                    PathID = component.PathID,
                                    Properties = new Dictionary<string, object> { ["ComponentType"] = componentType }
                                });
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"Could not resolve component for GameObject {gameObject.Name}: {ex.Message}");
                    }
                }

                // Aggregate all orb components if we found multiple
                if (orbComponentsFound.Count > 0)
                {
                    Logger.Debug($"üîÑ Aggregating {orbComponentsFound.Count} orb components for GameObject {gameObject.Name}");

                    // Create an aggregated orb data from all components
                    var aggregatedOrbData = AggregateOrbComponents(gameObject.Name, orbComponentsFound);
                    if (aggregatedOrbData != null)
                    {
                        // Apply token resolution if we have localization parameters
                        if (localizationParams != null && (localizationParams.ContainsKey("_HasLocalizationParams") || localizationParams.Count > 1))
                        {
                            // Use extracted parameters directly if available, otherwise fall back to known params
                            Dictionary<string, string> parametersToUse = localizationParams;
                            
                            if (localizationParams.ContainsKey("_HasLocalizationParams"))
                            {
                                // Get the orb level from the data for fallback
                                var orbLevel = 1;
                                if (aggregatedOrbData.RawData?.TryGetValue("Level", out var levelObj) == true &&
                                    int.TryParse(levelObj?.ToString(), out var parsedLevel))
                                {
                                    orbLevel = parsedLevel;
                                }
                                
                                // Get known parameters for this orb
                                var knownParams = GetKnownLocalizationParams(aggregatedOrbData.Name ?? "", orbLevel);
                                if (knownParams != null && knownParams.Count > 0)
                                {
                                    parametersToUse = knownParams;
                                }
                            }
                            
                            if (parametersToUse.Count > 0 && !parametersToUse.ContainsKey("_HasLocalizationParams"))
                            {
                                Logger.Debug($"üî§ Applying token resolution to orb {aggregatedOrbData.Name} with {parametersToUse.Count} parameters: {string.Join(", ", parametersToUse.Select(p => $"{p.Key}={p.Value}"))}");
                                
                                // Resolve tokens in name
                                if (!string.IsNullOrEmpty(aggregatedOrbData.Name))
                                {
                                    var resolvedName = ResolveTokens(aggregatedOrbData.Name, parametersToUse);
                                    if (resolvedName != aggregatedOrbData.Name)
                                    {
                                        Logger.Debug($"üî§ Resolved orb name: '{aggregatedOrbData.Name}' -> '{resolvedName}'");
                                        aggregatedOrbData.Name = resolvedName;
                                    }
                                }
                                
                                // Resolve tokens in description strings
                                if (aggregatedOrbData.DescriptionStrings != null && aggregatedOrbData.DescriptionStrings.Count > 0)
                                {
                                    var resolvedDescriptions = ResolveTokens(aggregatedOrbData.DescriptionStrings, parametersToUse);
                                    var hasChanges = false;
                                    for (int i = 0; i < aggregatedOrbData.DescriptionStrings.Count; i++)
                                    {
                                        if (i < resolvedDescriptions.Count && resolvedDescriptions[i] != aggregatedOrbData.DescriptionStrings[i])
                                        {
                                            hasChanges = true;
                                            Logger.Debug($"üî§ Resolved description[{i}]: '{aggregatedOrbData.DescriptionStrings[i]}' -> '{resolvedDescriptions[i]}'");
                                        }
                                    }
                                    if (hasChanges)
                                    {
                                        aggregatedOrbData.DescriptionStrings = resolvedDescriptions;
                                    }
                                }
                            }
                            else
                            {
                                Logger.Debug($"üî§ No parameters available for token resolution in orb {aggregatedOrbData.Name}");
                            }
                        }

                        gameObjectData.Name = aggregatedOrbData.Name ?? gameObject.Name;
                        gameObjectData.RawData = aggregatedOrbData.RawData;

                        // Store the aggregated component data
                        extractedComponentData["OrbComponent"] = aggregatedOrbData.RawData;
                        extractedComponentData["HasOrbData"] = true;
                        extractedComponentData["LocKey"] = aggregatedOrbData.LocKey;
                        extractedComponentData["DamagePerPeg"] = aggregatedOrbData.DamagePerPeg;
                        extractedComponentData["CritDamagePerPeg"] = aggregatedOrbData.CritDamagePerPeg;
                        extractedComponentData["ComponentCount"] = orbComponentsFound.Count;
                    }
                }

                // Store the extracted component data in RawData
                if (extractedComponentData.Count > 0)
                {
                    gameObjectInfo["ComponentData"] = extractedComponentData;
                }

                gameObjectData.RawData = gameObjectInfo;

                // For now, create a placeholder component based on the GameObject name
                var placeholderComponent = new ComponentData
                {
                    Type = DetermineComponentTypeFromName(gameObject.Name),
                    Name = gameObject.Name,
                    PathID = gameObject.PathID,
                    Properties = gameObjectInfo
                };

                gameObjectData.Components.Add(placeholderComponent);
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error extracting components for {gameObject.Name}: {ex.Message}");
            }
        }

        /// <summary>
        /// Aggregates multiple orb MonoBehaviour components into a single OrbData
        /// </summary>
        private OrbData? AggregateOrbComponents(string gameObjectName, List<Dictionary<string, object>> orbComponents)
        {
            if (orbComponents.Count == 0) return null;

            Logger.Debug($"üîÄ Aggregating {orbComponents.Count} orb components for {gameObjectName}");

            // Start with an empty dictionary to aggregate all fields
            var aggregatedData = new Dictionary<string, object>();

            // Merge all component data, later components can add to or override earlier ones
            foreach (var component in orbComponents)
            {
                foreach (var kvp in component)
                {
                    // For nested dictionaries, merge them recursively
                    if (kvp.Value is Dictionary<string, object> nestedDict &&
                        aggregatedData.TryGetValue(kvp.Key, out var existingValue) &&
                        existingValue is Dictionary<string, object> existingDict)
                    {
                        // Merge nested dictionaries
                        foreach (var nestedKvp in nestedDict)
                        {
                            existingDict[nestedKvp.Key] = nestedKvp.Value;
                        }
                    }
                    else
                    {
                        // For non-dictionary values or first occurrence, just set/override
                        // Prioritize non-null values
                        if (kvp.Value != null || !aggregatedData.ContainsKey(kvp.Key))
                        {
                            aggregatedData[kvp.Key] = kvp.Value;
                        }
                    }
                }
            }

            Logger.Debug($"üìä Aggregated data contains {aggregatedData.Count} fields from {orbComponents.Count} components");

            // Now extract an OrbData from the aggregated data
            var orbData = ExtractOrb(gameObjectName, aggregatedData);

            if (orbData != null)
            {
                // Store the aggregated raw data
                orbData.RawData = aggregatedData;
                Logger.Debug($"‚úÖ Successfully created aggregated OrbData for {gameObjectName} with {aggregatedData.Count} fields");
            }

            return orbData;
        }

        /// <summary>
        /// Determines component type from GameObject name
        /// </summary>
        private string DetermineComponentTypeFromName(string name)
        {
            var lowerName = name.ToLowerInvariant();

            // Guess component types based on naming patterns
            if (lowerName.Contains("attack") || lowerName.Contains("damage"))
                return "Attack";
            if (lowerName.Contains("ball") || lowerName.Contains("pachinko"))
                return "PachinkoBall";
            if (lowerName.Contains("orb"))
                return "OrbData";
            if (lowerName.Contains("upgrade"))
                return "UnlimitedUpgrades";

            return "MonoBehaviour";
        }

        /// <summary>
        /// Checks if a GameObject represents an orb
        /// </summary>
        private static bool IsOrbGameObject(GameObjectData gameObjectData)
        {
            var name = gameObjectData.Name.ToLowerInvariant();
            var id = gameObjectData.Id.ToLowerInvariant();

            // First, check for definite exclusions - UI elements, sprites, and non-gameplay objects
            var strongExcludePatterns = new[]
            {
                "ui", "menu", "button", "text", "canvas", "camera", "light", "manager",
                "controller", "system", "effect", "particle", "enemy", "relic", "statue",
                "icon", "image", "sprite", "background", "frame", "mask", "preview", "tooltip",
                "container", "panel", "widget", "display", "layout", "grid", "row", "option",
                "confirmation", "upgrade", "catalog", "editor", "select", "view", "boss", "prefab",
                "projectile", "arrow", "damage", "health", "flames", "explosion", "flash", "wheel",
                "progress", "details", "inventory", "carousel", "silhouette", "shadow", "outline",
                "transform", "spawntransform", "starttransform", "ballspawntransform",
                // Projectile/shot variants that are animations, not orbs
                "shot", "crit", "startup", "vine", "capsule", "stats", "doodad", "scenari",
                // UI-specific orb elements that aren't actual orbs
                "orbname", "orbcount", "orblist", "orbtitle", "orbinsert", "cycleorb",
                "cruciball", "debug", "navigation"
            };

            var isStronglyExcluded = strongExcludePatterns.Any(pattern =>
                name.Contains(pattern) || id.Contains(pattern));

            if (isStronglyExcluded)
            {
                return false;
            }

            // Check if the GameObject actually has OrbComponent data in its RawData
            if (gameObjectData.RawData is Dictionary<string, object> rawData)
            {
                // Look for ComponentData.OrbComponent structure which indicates actual orb data
                if (rawData.TryGetValue("ComponentData", out var componentDataObj) &&
                    componentDataObj is Dictionary<string, object> componentData &&
                    componentData.ContainsKey("OrbComponent"))
                {
                    Logger.Debug($"‚úÖ GameObject {name} has OrbComponent data - confirmed orb");
                    return true;
                }

                // Look for direct OrbComponent in RawData
                if (rawData.ContainsKey("OrbComponent"))
                {
                    Logger.Debug($"‚úÖ GameObject {name} has direct OrbComponent data - confirmed orb");
                    return true;
                }

                // Look for orb-specific fields that indicate this is actual orb data
                var orbSpecificFields = new[] { "DamagePerPeg", "CritDamagePerPeg", "Level", "locNameString", "locName" };
                var hasOrbFields = orbSpecificFields.Count(field => rawData.ContainsKey(field)) >= 3;

                if (hasOrbFields)
                {
                    Logger.Debug($"‚úÖ GameObject {name} has orb-specific fields - confirmed orb");
                    return true;
                }
            }

            // Check component types for specific orb-related components (more restrictive than before)
            var componentTypes = gameObjectData.Components.Select(c => c.Type.ToLowerInvariant()).ToList();
            var restrictiveOrbComponents = new[] { "pachinkoball", "orbdata", "unlimitedupgrades" };
            var hasRestrictiveOrbComponents = restrictiveOrbComponents.Any(pattern =>
                componentTypes.Any(type => type.Contains(pattern)));

            if (hasRestrictiveOrbComponents)
            {
                Logger.Debug($"‚úÖ GameObject {name} has restrictive orb components - confirmed orb");
                return true;
            }

            // Only include objects with "orb" or "-lvl" patterns that suggest they're actual orb entities
            var hasOrbPattern = name.Contains("orb") || name.Contains("-lvl") ||
                               id.Contains("orb") || id.Contains("-lvl");

            if (!hasOrbPattern)
            {
                Logger.Debug($"‚ùå GameObject {name} lacks orb patterns - not an orb");
                return false;
            }

            Logger.Debug($"üîç GameObject {name} passed basic orb pattern check but lacks component data");
            return false;
        }

        /// <summary>
        /// Converts GameObject data to OrbData
        /// </summary>
        private OrbData? ConvertGameObjectToOrbData(GameObjectData gameObjectData)
        {
            try
            {
                var orb = new OrbData
                {
                    Id = gameObjectData.Id,
                    Name = gameObjectData.Name,
                    RawData = gameObjectData.RawData
                };

                // Check if we have extracted component data with orb information
                if (gameObjectData.RawData != null &&
                    gameObjectData.RawData.TryGetValue("ComponentData", out var componentDataObj) &&
                    componentDataObj is Dictionary<string, object> componentData)
                {
                    // Use the extracted orb data from the MonoBehaviour component
                    if (componentData.TryGetValue("HasOrbData", out var hasOrbData) &&
                        hasOrbData is bool && (bool)hasOrbData)
                    {
                        // Extract all the orb fields we found
                        if (componentData.TryGetValue("LocKey", out var locKey))
                            orb.LocKey = locKey?.ToString();

                        if (componentData.TryGetValue("DamagePerPeg", out var damage))
                            orb.DamagePerPeg = damage as float?;

                        if (componentData.TryGetValue("CritDamagePerPeg", out var critDamage))
                            orb.CritDamagePerPeg = critDamage as float?;

                        // Extract description from componentData.OrbComponent.locDescription path
                        if (componentData.TryGetValue("OrbComponent", out var orbComponentObj) &&
                            orbComponentObj is Dictionary<string, object> orbComponent &&
                            orbComponent.TryGetValue("locDescription", out var locDescription))
                        {
                            // orb.Description = locDescription?.ToString() ?? ""; // Removed: use DescriptionStrings instead
                        }

                        // Extract and translate locDescStrings from componentData.OrbComponent.locDescStrings
                        if (componentData.TryGetValue("OrbComponent", out var orbComponentObjForStrings) &&
                            orbComponentObjForStrings is Dictionary<string, object> orbComponentForStrings &&
                            orbComponentForStrings.TryGetValue("locDescStrings", out var locDescStringsObj) &&
                            locDescStringsObj is IEnumerable<object> locDescStringsArray)
                        {
                            var locDescStrings = locDescStringsArray.Select(x => x?.ToString()).Where(x => !string.IsNullOrEmpty(x)).Cast<string>().ToList();

                            if (locDescStrings.Count > 0)
                            {
                                Logger.Debug($"üîç Found {locDescStrings.Count} locDescStrings for orb {orb.Name}: [{string.Join(", ", locDescStrings)}]");
                                try
                                {

                                    var translatedStrings = new List<string>();
                                    foreach (var descKey in locDescStrings)
                                    {
                                        var translation = localizationService.GetTranslation($"Orbs/{descKey}");
                                        Logger.Debug($"üî§ Translation for '{descKey}': '{translation}'");
                                        if (!string.IsNullOrWhiteSpace(translation))
                                        {
                                            translatedStrings.Add(translation);
                                        }
                                    }
                                    
                                    // Apply token resolution if we have LocalizationParams
                                    if (componentData.TryGetValue("LocalizationParams", out var locParamsObj) &&
                                        locParamsObj is Dictionary<string, string> locParams)
                                    {
                                        Logger.Debug($"üî§ Applying token resolution to {translatedStrings.Count} translated strings using {locParams.Count} parameters");
                                        var resolvedStrings = ResolveTokens(translatedStrings, locParams);
                                        
                                        // Log any resolved strings
                                        for (int i = 0; i < translatedStrings.Count; i++)
                                        {
                                            if (i < resolvedStrings.Count && resolvedStrings[i] != translatedStrings[i])
                                            {
                                                Logger.Debug($"üî§ Resolved translation[{i}]: '{translatedStrings[i]}' -> '{resolvedStrings[i]}'");
                                            }
                                        }
                                        
                                        orb.DescriptionStrings = resolvedStrings;
                                    }
                                    else
                                    {
                                        orb.DescriptionStrings = translatedStrings;
                                    }
                                    Logger.Debug($"‚úÖ Translated {translatedStrings.Count} description strings for orb {orb.Name}");
                                }
                                catch (Exception ex)
                                {
                                    Logger.Debug($"‚ö†Ô∏è Failed to get localized descriptions from locDescStrings for orb {orb.Name}: {ex.Message}");
                                }
                            }
                            else
                            {
                                Logger.Debug($"‚è≠Ô∏è No valid locDescStrings found for orb {orb.Name}");
                            }
                        }

                        // Set default values for other fields
                        orb.OrbType = "ATTACK";
                        orb.RarityValue = 1;
                        orb.Rarity = "COMMON";

                        Logger.Debug($"‚úÖ Successfully extracted orb data from GameObject {gameObjectData.Name}: LocKey={orb.LocKey}, Damage={orb.DamagePerPeg}");
                    }
                }
                else
                {
                    // Fallback: Try to extract damage values from component properties
                    foreach (var component in gameObjectData.Components)
                    {
                        if (component.Type.ToLowerInvariant().Contains("attack"))
                        {
                            // Try to find damage values in component properties
                            if (component.Properties.TryGetValue("DamagePerPeg", out var damage) &&
                                float.TryParse(damage?.ToString(), out var damageFloat))
                            {
                                orb.DamagePerPeg = damageFloat;
                            }
                            if (component.Properties.TryGetValue("CritDamagePerPeg", out var critDamage) &&
                                float.TryParse(critDamage?.ToString(), out var critDamageFloat))
                            {
                                orb.CritDamagePerPeg = critDamageFloat;
                            }
                        }
                    }
                }

                return orb;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error converting GameObject to OrbData: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Finds sprite reference for a GameObject by tracing orb -> PachinkoBall -> SpriteRenderer -> Sprite
        /// </summary>
        private IUnityAssetBase? FindGameObjectSpriteReference(IGameObject gameObject, Dictionary<long, IMonoBehaviour> componentMap,
            AssetCollection collection)
        {
            try
            {
                Logger.Debug($"üîç Tracing sprite reference for GameObject {gameObject.Name}");

                // Get all components from the GameObject
                var components = gameObject.FetchComponents();

                foreach (var componentPtr in components)
                {
                    try
                    {
                        var component = componentPtr.TryGetAsset(collection);
                        if (component is IMonoBehaviour monoBehaviour)
                        {
                            // Load the MonoBehaviour structure to check if it's PachinkoBall
                            var structure = monoBehaviour.LoadStructure();
                            if (structure != null)
                            {
                                var componentData = ConvertStructureToDict(structure, collection, out _);

                                // Check if this is a PachinkoBall MonoBehaviour by looking for _renderer field
                                if (componentData.ContainsKey("_renderer") || componentData.ContainsKey("renderer"))
                                {
                                    Logger.Debug($"‚úÖ Found PachinkoBall MonoBehaviour in GameObject {gameObject.Name}");

                                    // Extract the _renderer field (reference to SpriteRenderer)
                                    var rendererField = componentData.ContainsKey("_renderer") ? componentData["_renderer"] : componentData["renderer"];

                                    if (rendererField is Dictionary<string, object> rendererDict)
                                    {
                                        Logger.Debug($"üîÑ Processing _renderer reference in PachinkoBall");

                                        // Look for asset reference in the dictionary
                                        if (rendererDict.ContainsKey("type") && rendererDict.ContainsKey("pathId"))
                                        {
                                            var typeName = rendererDict["type"]?.ToString();
                                            var pathIdStr = rendererDict["pathId"]?.ToString();

                                            Logger.Debug($"üîç Found renderer reference: type={typeName}, pathId={pathIdStr}");

                                            if (typeName?.Contains("SpriteRenderer") == true && long.TryParse(pathIdStr, out var pathId))
                                            {
                                                // Find the SpriteRenderer component by PathID
                                                var spriteRenderer = FindAssetByPathId(collection, pathId);
                                                if (spriteRenderer != null)
                                                {
                                                    Logger.Debug($"‚úÖ Resolved SpriteRenderer: {spriteRenderer.GetType().Name}");

                                                    // Extract sprite reference from SpriteRenderer
                                                    var sprite = ExtractSpriteFromRenderer(spriteRenderer, collection);
                                                    if (sprite != null)
                                                    {
                                                        Logger.Debug($"‚úÖ Successfully traced sprite: {sprite.GetType().Name}");
                                                        return sprite;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (rendererField is IUnityAssetBase rendererAsset)
                                    {
                                        // Direct asset reference
                                        Logger.Debug($"üîÑ Processing direct _renderer asset in PachinkoBall");
                                        var sprite = ExtractSpriteFromRenderer(rendererAsset, collection);
                                        if (sprite != null)
                                        {
                                            Logger.Debug($"‚úÖ Successfully traced sprite from direct asset: {sprite.GetType().Name}");
                                            return sprite;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"Error processing component in GameObject {gameObject.Name}: {ex.Message}");
                    }
                }

                Logger.Debug($"‚ùå No sprite reference found for GameObject {gameObject.Name}");
                return null;
            }
            catch (Exception ex)
            {
                Logger.Debug($"Error finding sprite reference for GameObject {gameObject.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Finds an asset by PathID in the collection
        /// </summary>
        private IUnityAssetBase? FindAssetByPathId(AssetCollection collection, long pathId)
        {
            try
            {
                return collection.TryGetAsset(pathId);
            }
            catch (Exception ex)
            {
                Logger.Debug($"Error finding asset by PathID {pathId}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Resolves a PPtr reference to an actual asset
        /// </summary>
        private IUnityAssetBase? ResolvePPtr(object pptr, AssetCollection collection)
        {
            try
            {
                // Check if it's already an IUnityAssetBase
                if (pptr is IUnityAssetBase asset)
                {
                    return asset;
                }

                // Check if it has a TryGetAsset method (for PPtr types)
                var tryGetMethod = pptr.GetType().GetMethod("TryGetAsset");
                if (tryGetMethod != null)
                {
                    var result = tryGetMethod.Invoke(pptr, new object[] { collection });
                    return result as IUnityAssetBase;
                }

                // Try to get PathID property and resolve it
                var pathIdProperty = pptr.GetType().GetProperty("PathID")
                    ?? pptr.GetType().GetProperty("M_PathID")
                    ?? pptr.GetType().GetProperty("m_PathID");

                if (pathIdProperty != null)
                {
                    var pathIdValue = pathIdProperty.GetValue(pptr);
                    if (pathIdValue is long pathId)
                    {
                        return collection.TryGetAsset(pathId);
                    }
                }

                Logger.Debug($"Could not resolve PPtr of type {pptr.GetType().Name}");
                return null;
            }
            catch (Exception ex)
            {
                Logger.Debug($"Error resolving PPtr: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Extracts sprite reference from a SpriteRenderer component
        /// </summary>
        private IUnityAssetBase? ExtractSpriteFromRenderer(IUnityAssetBase spriteRenderer, AssetCollection collection)
        {
            try
            {
                // Try to extract sprite field from the component data
                if (spriteRenderer is IMonoBehaviour rendererBehaviour)
                {
                    var structure = rendererBehaviour.LoadStructure();
                    if (structure != null)
                    {
                        var rendererData = ConvertStructureToDict(structure, collection, out var spriteReference);

                        // If ConvertStructureToDict found a sprite reference directly, return it
                        if (spriteReference != null)
                        {
                            Logger.Debug($"‚úÖ Found sprite reference from structure: {spriteReference.GetType().Name}");
                            return spriteReference;
                        }

                        // Otherwise, look for sprite fields manually
                        return ExtractSpriteFromRendererDict(rendererData, collection);
                    }
                }

                return null;
            }
            catch (Exception ex)
            {
                Logger.Debug($"Error extracting sprite from renderer: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Extracts sprite reference from SpriteRenderer data dictionary
        /// </summary>
        private IUnityAssetBase? ExtractSpriteFromRendererDict(Dictionary<string, object> rendererData, AssetCollection collection)
        {
            try
            {
                // Look for common sprite field names in SpriteRenderer
                var spriteFieldNames = new[] { "m_Sprite", "sprite", "Sprite", "m_sprite" };

                foreach (var fieldName in spriteFieldNames)
                {
                    if (rendererData.ContainsKey(fieldName))
                    {
                        var spriteField = rendererData[fieldName];

                        if (spriteField is Dictionary<string, object> spriteDict)
                        {
                            // Handle asset reference dictionary
                            if (spriteDict.ContainsKey("type") && spriteDict.ContainsKey("pathId"))
                            {
                                var typeName = spriteDict["type"]?.ToString();
                                var pathIdStr = spriteDict["pathId"]?.ToString();

                                Logger.Debug($"üîÑ Following {fieldName} reference: type={typeName}, pathId={pathIdStr}");

                                if (long.TryParse(pathIdStr, out var pathId))
                                {
                                    var sprite = FindAssetByPathId(collection, pathId);
                                    if (sprite != null)
                                    {
                                        Logger.Debug($"‚úÖ Resolved sprite from {fieldName}: {sprite.GetType().Name}");
                                        return sprite;
                                    }
                                }
                            }
                        }
                        else if (spriteField is IUnityAssetBase spriteAsset)
                        {
                            Logger.Debug($"‚úÖ Direct sprite asset from {fieldName}: {spriteAsset.GetType().Name}");
                            return spriteAsset;
                        }
                    }
                }

                return null;
            }
            catch (Exception ex)
            {
                Logger.Debug($"Error extracting sprite from renderer dictionary: {ex.Message}");
                return null;
            }
        }

        // Helper methods
        private static bool IsSpriteField(string? fieldName)
        {
            if (string.IsNullOrEmpty(fieldName)) return false;
            var spriteFieldNames = new[] { "sprite", "icon", "image", "texture", "picture", "graphic", "avatar" };
            return spriteFieldNames.Any(name => fieldName.Contains(name));
        }

        /// <summary>
        /// More aggressive check for potential sprite fields based on common Unity patterns
        /// </summary>
        private static bool CouldBeSpriteField(string fieldName)
        {
            if (string.IsNullOrEmpty(fieldName)) return false;

            var fieldLower = fieldName.ToLowerInvariant();

            // Common patterns in Unity assets
            var potentialSpritePatterns = new[]
            {
                "icon", "sprite", "image", "texture", "graphic", "picture", "avatar",
                "prefabAssetReference", // Unity Addressable references
                "asset", // Generic asset references
                "visual", "portrait", "thumbnail"
            };

            return potentialSpritePatterns.Any(pattern => fieldLower.Contains(pattern));
        }

        /// <summary>
        /// Checks if a field contains a GUID-based asset reference (Unity Addressables)
        /// </summary>
        private static bool IsGuidAssetReference(object? value)
        {
            if (value is Dictionary<string, object> dict)
            {
                return dict.ContainsKey("m_AssetGUID") &&
                       dict.TryGetValue("m_AssetGUID", out var guid) &&
                       !string.IsNullOrEmpty(guid?.ToString());
            }
            return false;
        }

        private static string CleanEntityId(string id)
        {
            if (string.IsNullOrEmpty(id)) return "unknown";
            id = id.Replace("Relic_", "").Replace("_Relic", "").Replace(".asset", "");
            id = id.Replace("Enemy_", "").Replace("_Enemy", "");
            id = id.Replace("Orb_", "").Replace("_Orb", "");
            id = id.ToLowerInvariant().Replace(" ", "_");
            return id;
        }

        private static string GenerateSpriteId(string name)
        {
            if (string.IsNullOrEmpty(name)) return $"sprite_{Guid.NewGuid():N}";
            return name.Replace(" ", "_").Replace(".", "_").ToLowerInvariant();
        }

        private static SpriteCacheManager.SpriteType DetermineSpriteType(string name)
        {
            var nameLower = name?.ToLowerInvariant() ?? "";

            if (nameLower.Contains("relic") || nameLower.Contains("artifact") || nameLower.Contains("item"))
                return SpriteCacheManager.SpriteType.Relic;

            if (nameLower.Contains("enemy") || nameLower.Contains("monster") || nameLower.Contains("boss"))
                return SpriteCacheManager.SpriteType.Enemy;

            if (nameLower.Contains("orb") || nameLower.Contains("ball") || nameLower.Contains("projectile"))
                return SpriteCacheManager.SpriteType.Orb;

            return SpriteCacheManager.SpriteType.Orb; // Default to Orb for unknowns
        }

        /// <summary>
        /// Converts a Texture2D to PNG format and saves it to disk
        /// </summary>
        private bool ConvertTextureToPng(ITexture2D texture, string outputPath)
        {
            try
            {
                Logger.Debug($"üîÑ Converting texture '{texture.Name}' to PNG...");

                var directory = Path.GetDirectoryName(outputPath);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Use AssetRipper's TextureConverter to convert to DirectBitmap
                if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
                {
                    Logger.Debug($"‚úÖ Successfully converted texture '{texture.Name}' to bitmap");

                    // Save as PNG using AssetRipper's built-in PNG export
                    using var fileStream = File.Create(outputPath);
                    bitmap.SaveAsPng(fileStream);
                    // DirectBitmap doesn't have Dispose, it's managed by GC

                    Logger.Debug($"üéâ Successfully saved PNG to: {outputPath}");
                    return true;
                }
                else
                {
                    Logger.Warning($"‚ùå Failed to convert texture '{texture.Name}' to bitmap - format may not be supported");
                    return false;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"‚ùå Error converting texture '{texture.Name}' to PNG: {ex.Message}");
                return false;
            }
        }

        private static string GetSpriteFilePath(string spriteId, SpriteCacheManager.SpriteType type)
        {
            var folder = type switch
            {
                SpriteCacheManager.SpriteType.Relic => "extracted-data/sprites/relics",
                SpriteCacheManager.SpriteType.Enemy => "extracted-data/sprites/enemies",
                SpriteCacheManager.SpriteType.Orb => "extracted-data/sprites/orbs",
                _ => "extracted-data/sprites/unknown"
            };

            return $"{folder}/{spriteId}.png";
        }

        /// <summary>
        /// Extracts sprite metadata with improved processing (incorporating AssetRipperSpriteExtractor techniques)
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ExtractSpriteWithImprovedProcessing(ISprite sprite)
        {
            try
            {
                var spriteName = CleanSpriteName(sprite.Name);
                var spriteType = DetermineSpriteType(spriteName);
                var spriteId = GenerateSpriteId(spriteName);

                Logger.Debug($"üéØ Processing sprite '{spriteName}' as {spriteType} with ID: {spriteId}");

                var metadata = new SpriteCacheManager.SpriteMetadata
                {
                    Id = spriteId,
                    Name = spriteName,
                    Type = spriteType,
                    FilePath = GetSpriteFilePath(spriteId, spriteType),
                    SourceBundle = "", // Will be set by caller
                    ExtractedAt = DateTime.Now,
                    IsAtlas = false
                };

                // Get the texture from the sprite and save it
                var texture = sprite.TryGetTexture();
                if (texture != null)
                {
                    metadata.Width = texture.Width_C28;
                    metadata.Height = texture.Height_C28;

                    // Set frame dimensions from sprite's TextureRect
                    metadata.FrameWidth = (int)sprite.RD.TextureRect.Width;
                    metadata.FrameHeight = (int)sprite.RD.TextureRect.Height;
                    metadata.FrameX = (int)sprite.RD.TextureRect.X;
                    metadata.FrameY = (int)sprite.RD.TextureRect.Y;

                    // Calculate frame count if this is a sprite sheet
                    var frameCount = 1;
                    if (metadata.FrameWidth > 0 && metadata.FrameHeight > 0 &&
                        (metadata.Width > metadata.FrameWidth || metadata.Height > metadata.FrameHeight))
                    {
                        var framesX = metadata.Width / metadata.FrameWidth;
                        var framesY = metadata.Height / metadata.FrameHeight;
                        frameCount = Math.Max(1, framesX * framesY);
                        Logger.Debug($"Detected sprite sheet {spriteName}: {frameCount} frames ({framesX}x{framesY})");
                        metadata.IsAtlas = frameCount > 1;
                    }
                    metadata.FrameCount = frameCount;

                    // Use improved conversion method
                    if (ConvertTextureToPngImproved(texture, metadata.FilePath, spriteName))
                    {
                        Logger.Debug($"‚úÖ Successfully processed sprite: {spriteName} -> {spriteId}");
                        return metadata;
                    }
                    else
                    {
                        Logger.Warning($"‚ùå Failed to convert sprite texture: {spriteName}");
                        return null;
                    }
                }
                else
                {
                    Logger.Verbose($"‚ùå Could not get texture from sprite: {spriteName}");
                    return null;
                }
            }
            catch (Exception ex)
            {
                Logger.Verbose($"Error processing sprite {sprite.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Extracts texture metadata with improved processing (incorporating AssetRipperSpriteExtractor techniques)
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ExtractTextureWithImprovedProcessing(ITexture2D texture)
        {
            try
            {
                var textureName = CleanSpriteName(texture.Name);
                var spriteType = DetermineSpriteType(textureName);
                var spriteId = GenerateSpriteId(textureName);

                Logger.Debug($"üéØ Processing texture '{textureName}' as {spriteType} with ID: {spriteId}");

                var metadata = new SpriteCacheManager.SpriteMetadata
                {
                    Id = spriteId,
                    Name = textureName,
                    Type = spriteType,
                    Width = texture.Width_C28,
                    Height = texture.Height_C28,
                    // For standalone textures, frame dimensions equal texture dimensions
                    FrameWidth = texture.Width_C28,
                    FrameHeight = texture.Height_C28,
                    FrameX = 0,
                    FrameY = 0,
                    FilePath = GetSpriteFilePath(spriteId, spriteType),
                    SourceBundle = "", // Will be set by caller
                    ExtractedAt = DateTime.Now,
                    IsAtlas = DetectIfSpriteSheet(textureName, texture.Width_C28, texture.Height_C28)
                };

                // Convert and save the texture
                if (ConvertTextureToPngImproved(texture, metadata.FilePath, textureName))
                {
                    Logger.Debug($"‚úÖ Successfully processed texture: {textureName} -> {spriteId}");
                    return metadata;
                }
                else
                {
                    Logger.Warning($"‚ùå Failed to convert texture: {textureName}");
                    return null;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error processing texture {texture.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Extracts sprite metadata with forced sprite type (overrides automatic type detection)
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ExtractSpriteWithImprovedProcessing(ISprite sprite, SpriteCacheManager.SpriteType forcedType)
        {
            try
            {
                var spriteName = CleanSpriteName(sprite.Name);
                var spriteId = GenerateSpriteId(spriteName);

                Logger.Debug($"üéØ Processing sprite '{spriteName}' with FORCED type {forcedType} and ID: {spriteId}");

                if (sprite.RD.Texture.TryGetAsset(sprite.Collection, out ITexture2D? texture) && texture != null)
                {
                    var frameWidth = (int)sprite.RD.TextureRect.Width;
                    var frameHeight = (int)sprite.RD.TextureRect.Height;
                    var textureWidth = texture.Width_C28;
                    var textureHeight = texture.Height_C28;

                    // Calculate frame count if this is a sprite sheet
                    var frameCount = 1;
                    if (frameWidth > 0 && frameHeight > 0 &&
                        (textureWidth > frameWidth || textureHeight > frameHeight))
                    {
                        var framesX = textureWidth / frameWidth;
                        var framesY = textureHeight / frameHeight;
                        frameCount = Math.Max(1, framesX * framesY);
                        Logger.Debug($"Detected sprite sheet {spriteName}: {frameCount} frames ({framesX}x{framesY})");
                    }

                    var metadata = new SpriteCacheManager.SpriteMetadata
                    {
                        Id = spriteId,
                        Name = spriteName,
                        Type = forcedType,
                        Width = textureWidth,
                        Height = textureHeight,
                        FrameWidth = frameWidth,
                        FrameHeight = frameHeight,
                        FrameX = (int)sprite.RD.TextureRect.X,
                        FrameY = (int)sprite.RD.TextureRect.Y,
                        FrameCount = frameCount,
                        IsAtlas = frameCount > 1,
                        FilePath = GetSpriteFilePath(spriteId, forcedType),
                        SourceBundle = ""
                    };

                    var saved = ConvertTextureToPngImproved(texture, metadata.FilePath, spriteName);
                    if (saved)
                    {
                        Logger.Verbose($"‚úÖ Extracted sprite: {spriteName} -> {metadata.FilePath} (forced type: {forcedType})");
                        return metadata;
                    }
                }

                Logger.Warning($"‚ùå Failed to extract sprite: {spriteName}");
                return null;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error processing sprite {sprite.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Extracts texture metadata with forced sprite type (overrides automatic type detection)  
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ExtractTextureWithImprovedProcessing(ITexture2D texture, SpriteCacheManager.SpriteType forcedType)
        {
            try
            {
                var textureName = CleanSpriteName(texture.Name);
                var spriteId = GenerateSpriteId(textureName);

                Logger.Debug($"üéØ Processing texture '{textureName}' with FORCED type {forcedType} and ID: {spriteId}");

                var metadata = new SpriteCacheManager.SpriteMetadata
                {
                    Id = spriteId,
                    Name = textureName,
                    Type = forcedType,
                    Width = texture.Width_C28,
                    Height = texture.Height_C28,
                    // For standalone textures, frame dimensions equal texture dimensions
                    FrameWidth = texture.Width_C28,
                    FrameHeight = texture.Height_C28,
                    FrameX = 0,
                    FrameY = 0,
                    FilePath = GetSpriteFilePath(spriteId, forcedType),
                    SourceBundle = ""
                };

                var saved = ConvertTextureToPngImproved(texture, metadata.FilePath, textureName);
                if (saved)
                {
                    Logger.Verbose($"‚úÖ Extracted texture: {textureName} -> {metadata.FilePath} (forced type: {forcedType})");
                    return metadata;
                }
                else
                {
                    Logger.Warning($"‚ùå Failed to convert texture: {textureName}");
                    return null;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error processing texture {texture.Name}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Improved PNG conversion with better error handling and logging
        /// </summary>
        private bool ConvertTextureToPngImproved(ITexture2D texture, string relativePath, string displayName)
        {
            try
            {
                var cacheDir = PeglinDataExtractor.GetExtractionCacheDirectory();
                var fullPath = Path.Combine(cacheDir, relativePath);
                var directory = Path.GetDirectoryName(fullPath);

                Logger.Debug($"üíæ Saving sprite '{displayName}' to: {fullPath}");

                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Use AssetRipper's TextureConverter to convert to DirectBitmap
                if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
                {
                    Logger.Debug($"‚úÖ Converted texture '{displayName}' to bitmap ({texture.Width_C28}x{texture.Height_C28})");

                    // Save as PNG using AssetRipper's built-in PNG export
                    using var fileStream = File.Create(fullPath);
                    bitmap.SaveAsPng(fileStream);

                    Logger.Debug($"üéâ Successfully saved PNG: {Path.GetFileName(fullPath)} (format: {texture.Format_C28E})");
                    return true;
                }
                else
                {
                    Logger.Warning($"‚ùå Failed to convert texture '{displayName}' to bitmap - format '{texture.Format_C28E}' may not be supported");
                    return false;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"‚ùå Error saving sprite '{displayName}': {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Detects if a texture is likely a sprite sheet based on naming and dimensions
        /// (Borrowed from AssetRipperSpriteExtractor)
        /// </summary>
        private bool DetectIfSpriteSheet(string name, int width, int height)
        {
            var lowerName = name.ToLowerInvariant();

            // Check for sprite sheet naming patterns
            var spriteSheetPatterns = new[]
            {
                "spritesheet", "sheet", "anim", "animated", "frames", "idle", "walk", "run", "attack", "death", "hurt"
            };

            var hasSpriteSheetName = spriteSheetPatterns.Any(pattern => lowerName.Contains(pattern));

            // Check for dimensions that suggest a sprite sheet
            var possibleFrameSizes = new[] { 16, 24, 32, 48, 64, 80, 96, 128, 160 };

            // Check if width is a multiple of height (horizontal strip)
            var isHorizontalStrip = height <= 160 && width > height && width % height == 0 && (width / height) >= 2;

            // Check if height is a multiple of width (vertical strip) 
            var isVerticalStrip = width <= 160 && height > width && height % width == 0 && (height / width) >= 2;

            // Check if both dimensions are multiples of common frame sizes (grid layout)
            var isGrid = possibleFrameSizes.Any(frameSize =>
                width >= frameSize * 2 && height >= frameSize * 2 &&
                width % frameSize == 0 && height % frameSize == 0);

            var result = hasSpriteSheetName || isHorizontalStrip || isVerticalStrip || isGrid;

            if (result)
            {
                Logger.Debug($"üéûÔ∏è Detected sprite sheet: {name} ({width}x{height})");
            }

            return result;
        }

        /// <summary>
        /// Cleans sprite names by removing common suffixes and prefixes
        /// </summary>
        private string CleanSpriteName(string name)
        {
            if (string.IsNullOrEmpty(name)) return "unknown";

            // Remove common Unity asset suffixes
            var cleaned = name;
            var suffixesToRemove = new[] { "(Clone)", "_1", "_2", "_3", "_Instance" };
            foreach (var suffix in suffixesToRemove)
            {
                if (cleaned.EndsWith(suffix, StringComparison.OrdinalIgnoreCase))
                {
                    cleaned = cleaned[..^suffix.Length];
                }
            }

            return cleaned.Trim();
        }

        /// <summary>
        /// Builds a lookup table from sprite PathID to texture PathID using SpriteInformationObject assets
        /// </summary>
        private Dictionary<long, long> BuildSpriteInformationLookup(AssetCollection collection, GameBundle gameBundle)
        {
            var spriteToTextureLookup = new Dictionary<long, long>();

            try
            {
                // Look for SpriteInformationObject assets in all collections
                foreach (var assetCollection in gameBundle.FetchAssetCollections())
                {
                    foreach (var asset in assetCollection.Assets)
                    {
                        if (asset.Value == null) continue;

                        var assetType = asset.Value.GetType().Name;

                        // Look for any asset that contains sprite information mapping
                        // This could be named differently but should have Texture and Sprites properties
                        if (assetType.Contains("SpriteInformation", StringComparison.OrdinalIgnoreCase) ||
                            assetType.Contains("SpriteAtlas", StringComparison.OrdinalIgnoreCase) ||
                            HasSpriteInformationProperties(asset.Value))
                        {
                            Logger.Debug($"üó∫Ô∏è Found potential sprite information object: {assetType}");
                            ProcessSpriteInformationObject(asset.Value, spriteToTextureLookup);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error building sprite information lookup: {ex.Message}");
            }

            return spriteToTextureLookup;
        }

        /// <summary>
        /// Checks if an asset has properties that suggest it contains sprite information
        /// </summary>
        private bool HasSpriteInformationProperties(IUnityObjectBase asset)
        {
            try
            {
                var type = asset.GetType();
                var hasTexture = type.GetProperty("Texture") != null;
                var hasSprites = type.GetProperty("Sprites") != null;

                return hasTexture && hasSprites;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Processes a sprite information object to extract sprite PathID -> texture PathID mappings
        /// </summary>
        private void ProcessSpriteInformationObject(IUnityObjectBase spriteInfoObject, Dictionary<long, long> spriteToTextureLookup)
        {
            try
            {
                Logger.Debug($"üîç Processing sprite information object: {spriteInfoObject.GetType().Name}");

                // Get the Texture property (should point to the actual texture)
                var textureProperty = spriteInfoObject.GetType().GetProperty("Texture");
                if (textureProperty == null)
                {
                    Logger.Debug($"‚ùå No Texture property found on {spriteInfoObject.GetType().Name}");
                    return;
                }

                var textureRef = textureProperty.GetValue(spriteInfoObject);
                var texturePathId = ExtractPathIdFromReference(textureRef);

                if (texturePathId == 0)
                {
                    Logger.Debug($"‚ùå Could not extract texture PathID from reference");
                    return;
                }

                Logger.Debug($"üéØ Found texture PathID: {texturePathId}");

                // Get the Sprites property (should be a collection of sprite PathID mappings)
                var spritesProperty = spriteInfoObject.GetType().GetProperty("Sprites");
                if (spritesProperty == null)
                {
                    Logger.Debug($"‚ùå No Sprites property found on {spriteInfoObject.GetType().Name}");
                    return;
                }

                var spritesValue = spritesProperty.GetValue(spriteInfoObject);
                if (spritesValue == null)
                {
                    Logger.Debug($"‚ùå Sprites property is null");
                    return;
                }

                // Process the sprites collection (likely a Dictionary or Array of Key-Value pairs)
                ProcessSpritesCollection(spritesValue, texturePathId, spriteToTextureLookup);

            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ùå Error processing sprite information object: {ex.Message}");
            }
        }

        /// <summary>
        /// Processes a collection of sprite mappings (sprite PathID -> texture PathID)
        /// </summary>
        private void ProcessSpritesCollection(object spritesCollection, long texturePathId, Dictionary<long, long> spriteToTextureLookup)
        {
            try
            {
                // Handle different collection types
                if (spritesCollection is System.Collections.IEnumerable enumerable)
                {
                    foreach (var item in enumerable)
                    {
                        if (item == null) continue;

                        // Look for Key property (sprite PathID)
                        var keyProperty = item.GetType().GetProperty("Key");
                        if (keyProperty != null)
                        {
                            var keyValue = keyProperty.GetValue(item);
                            var spritePathId = ExtractPathIdFromReference(keyValue);

                            if (spritePathId != 0)
                            {
                                spriteToTextureLookup[spritePathId] = texturePathId;
                                Logger.Debug($"üó∫Ô∏è Mapped sprite PathID {spritePathId} -> texture PathID {texturePathId}");
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ùå Error processing sprites collection: {ex.Message}");
            }
        }

        /// <summary>
        /// Extracts PathID from a Unity asset reference (handles PPtr structures)
        /// </summary>
        private long ExtractPathIdFromReference(object? reference)
        {
            if (reference == null) return 0;

            try
            {
                // Look for m_PathID property (standard Unity reference structure)
                var pathIdProperty = reference.GetType().GetProperty("m_PathID");
                if (pathIdProperty != null)
                {
                    var pathIdValue = pathIdProperty.GetValue(reference);
                    if (pathIdValue is long pathId)
                    {
                        return pathId;
                    }
                    if (pathIdValue is int intPathId)
                    {
                        return intPathId;
                    }
                }

                // Also try PathID (without m_ prefix)
                var pathIdProperty2 = reference.GetType().GetProperty("PathID");
                if (pathIdProperty2 != null)
                {
                    var pathIdValue = pathIdProperty2.GetValue(reference);
                    if (pathIdValue is long pathId)
                    {
                        return pathId;
                    }
                    if (pathIdValue is int intPathId)
                    {
                        return intPathId;
                    }
                }
            }
            catch
            {
                // Ignore extraction errors
            }

            return 0;
        }

        /// <summary>
        /// Resolves a sprite reference using the sprite information lookup table
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ResolveSpriteWithLookup(IUnityAssetBase spriteRef, GameBundle gameBundle, Dictionary<long, long> spriteInfoLookup, SpriteCacheManager.SpriteType? forcedSpriteType = null)
        {
            try
            {
                // First, try to extract PathID from the sprite reference
                var spritePathId = ExtractPathIdFromAsset(spriteRef);
                if (spritePathId != 0)
                {
                    Logger.Debug($"üîç Looking up sprite PathID {spritePathId} in sprite info lookup table");

                    // Check if this sprite PathID maps to a texture PathID
                    if (spriteInfoLookup.TryGetValue(spritePathId, out var texturePathId))
                    {
                        Logger.Debug($"üó∫Ô∏è Found mapping: sprite PathID {spritePathId} -> texture PathID {texturePathId}");

                        // Now find the texture with this PathID across all collections
                        var texture = FindTextureByPathId(texturePathId, gameBundle);
                        if (texture != null)
                        {
                            Logger.Debug($"‚úÖ Found texture for PathID {texturePathId}: {texture.Name}");
                            return forcedSpriteType.HasValue
                                ? ExtractTextureWithImprovedProcessing(texture, forcedSpriteType.Value)
                                : ExtractTextureWithImprovedProcessing(texture);
                        }
                        else
                        {
                            Logger.Debug($"‚ùå Could not find texture with PathID {texturePathId}");
                        }
                    }
                    else
                    {
                        Logger.Debug($"‚ùå No mapping found for sprite PathID {spritePathId}");
                    }
                }

                // Fall back to original resolution method
                Logger.Debug($"üîÑ Falling back to original sprite resolution method");
                return forcedSpriteType.HasValue
                    ? ResolveSprite(spriteRef, gameBundle, forcedSpriteType.Value)
                    : ResolveSprite(spriteRef, gameBundle);
            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ùå Error in sprite lookup resolution: {ex.Message}");
                // Fall back to original resolution method
                return forcedSpriteType.HasValue
                    ? ResolveSprite(spriteRef, gameBundle, forcedSpriteType.Value)
                    : ResolveSprite(spriteRef, gameBundle);
            }
        }

        /// <summary>
        /// Extracts PathID from a Unity asset
        /// </summary>
        private long ExtractPathIdFromAsset(IUnityAssetBase asset)
        {
            try
            {
                // Try PathID property
                var pathIdProperty = asset.GetType().GetProperty("PathID");
                if (pathIdProperty != null)
                {
                    var pathIdValue = pathIdProperty.GetValue(asset);
                    if (pathIdValue is long pathId)
                    {
                        return pathId;
                    }
                    if (pathIdValue is int intPathId)
                    {
                        return intPathId;
                    }
                }

                // For PPtr types, look for the m_PathID field in the referenced object
                if (asset.GetType().Name.StartsWith("PPtr_"))
                {
                    // Try to get the PathID from PPtr structure
                    var fields = asset.GetType().GetFields();
                    foreach (var field in fields)
                    {
                        if (field.Name.Contains("PathID") || field.Name.Contains("m_PathID"))
                        {
                            var value = field.GetValue(asset);
                            if (value is long lValue) return lValue;
                            if (value is int iValue) return iValue;
                        }
                    }
                }
            }
            catch
            {
                // Ignore extraction errors
            }

            return 0;
        }

        /// <summary>
        /// Finds a texture asset by PathID across all collections in the game bundle
        /// </summary>
        private ITexture2D? FindTextureByPathId(long pathId, GameBundle gameBundle)
        {
            try
            {
                foreach (var collection in gameBundle.FetchAssetCollections())
                {
                    if (collection.Assets.TryGetValue(pathId, out var asset) && asset is ITexture2D texture)
                    {
                        return texture;
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ùå Error finding texture by PathID {pathId}: {ex.Message}");
            }

            return null;
        }

        /// <summary>
        /// Attempts to process any asset that might be sprite-related (including SpriteInformationObject)
        /// </summary>
        private SpriteCacheManager.SpriteMetadata? ProcessPotentialSpriteAsset(IUnityObjectBase asset, string bundleName)
        {
            try
            {
                var assetType = asset.GetType().Name;
                var assetName = asset.ToString() ?? "unknown";

                Logger.Debug($"üîç Processing potential sprite asset: {assetType} - {assetName}");

                // Handle ISprite (should already be processed, but just in case)
                if (asset is ISprite sprite)
                {
                    return ExtractSpriteWithImprovedProcessing(sprite);
                }

                // Handle ITexture2D directly
                if (asset is ITexture2D texture)
                {
                    return ExtractTextureWithImprovedProcessing(texture);
                }

                // Try to handle other potential sprite types through reflection
                // This is where we'd handle SpriteInformationObject and similar types

                // Look for texture-related properties using reflection
                var textureProperty = asset.GetType().GetProperty("Texture");
                var textureField = asset.GetType().GetField("texture");

                if (textureProperty != null)
                {
                    Logger.Debug($"üîç Found Texture property on {assetType}");
                    var textureValue = textureProperty.GetValue(asset);
                    if (textureValue is ITexture2D reflectionTexture)
                    {
                        Logger.Debug($"‚úÖ Successfully got texture from {assetType} via Texture property");
                        var metadata = ExtractTextureWithImprovedProcessing(reflectionTexture);
                        if (metadata != null)
                        {
                            metadata.Name = CleanSpriteName(assetName); // Use the sprite asset name, not texture name
                            metadata.SourceBundle = bundleName;
                        }
                        return metadata;
                    }
                }

                if (textureField != null)
                {
                    Logger.Debug($"üîç Found texture field on {assetType}");
                    var textureValue = textureField.GetValue(asset);
                    if (textureValue is ITexture2D reflectionTexture)
                    {
                        Logger.Debug($"‚úÖ Successfully got texture from {assetType} via texture field");
                        var metadata = ExtractTextureWithImprovedProcessing(reflectionTexture);
                        if (metadata != null)
                        {
                            metadata.Name = CleanSpriteName(assetName); // Use the sprite asset name, not texture name
                            metadata.SourceBundle = bundleName;
                        }
                        return metadata;
                    }
                }

                // Look for sprite-related properties
                var spriteProperties = asset.GetType().GetProperties()
                    .Where(p => p.Name.Contains("Sprite", StringComparison.OrdinalIgnoreCase))
                    .ToList();

                foreach (var spriteProp in spriteProperties)
                {
                    Logger.Debug($"üîç Found sprite property: {spriteProp.Name} on {assetType}");
                    try
                    {
                        var spriteValue = spriteProp.GetValue(asset);
                        if (spriteValue is ISprite reflectionSprite)
                        {
                            Logger.Debug($"‚úÖ Successfully got sprite from {assetType} via {spriteProp.Name}");
                            var metadata = ExtractSpriteWithImprovedProcessing(reflectionSprite);
                            if (metadata != null)
                            {
                                metadata.SourceBundle = bundleName;
                            }
                            return metadata;
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"‚ö†Ô∏è Error accessing sprite property {spriteProp.Name}: {ex.Message}");
                    }
                }

                Logger.Debug($"‚ùå Could not extract sprite/texture from {assetType}: {assetName}");
                return null;
            }
            catch (Exception ex)
            {
                Logger.Debug($"‚ùå Error processing potential sprite asset: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Dumps comprehensive asset properties for analysis to understand sprite reference structures
        /// </summary>
        private void DumpAssetPropertiesForAnalysis(IUnityObjectBase asset, string contextName)
        {
            try
            {
                var assetType = asset.GetType();
                var assetName = asset.ToString() ?? "Unknown";

                Logger.Info($"üîç === ASSET PROPERTY DUMP: {contextName} ===");
                Logger.Info($"   Type: {assetType.Name}");
                Logger.Info($"   Name: {assetName}");
                Logger.Info($"   Full Type: {assetType.FullName}");

                // Dump all properties
                var properties = assetType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance)
                    .Where(p => p.CanRead)
                    .OrderBy(p => p.Name)
                    .ToList();

                Logger.Info($"   Properties ({properties.Count}):");
                foreach (var prop in properties)
                {
                    try
                    {
                        var value = prop.GetValue(asset);
                        var valueStr = FormatPropertyValue(value, prop.PropertyType);
                        Logger.Info($"     {prop.Name} ({prop.PropertyType.Name}): {valueStr}");

                        // If this property contains texture/sprite references, log additional details
                        if (value is IUnityObjectBase refAsset)
                        {
                            Logger.Info($"       -> References: {refAsset.GetType().Name} '{refAsset}'");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Info($"     {prop.Name} ({prop.PropertyType.Name}): [Error: {ex.Message}]");
                    }
                }

                // Dump all fields
                var fields = assetType.GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance)
                    .OrderBy(f => f.Name)
                    .ToList();

                if (fields.Any())
                {
                    Logger.Info($"   Fields ({fields.Count}):");
                    foreach (var field in fields)
                    {
                        try
                        {
                            var value = field.GetValue(asset);
                            var valueStr = FormatPropertyValue(value, field.FieldType);
                            Logger.Info($"     {field.Name} ({field.FieldType.Name}): {valueStr}");

                            // If this field contains texture/sprite references, log additional details
                            if (value is IUnityObjectBase refAsset)
                            {
                                Logger.Info($"       -> References: {refAsset.GetType().Name} '{refAsset}'");
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.Info($"     {field.Name} ({field.FieldType.Name}): [Error: {ex.Message}]");
                        }
                    }
                }

                // Look specifically for any members that might contain "texture", "sprite", or "image" in their names
                var spriteRelatedMembers = properties.Cast<System.Reflection.MemberInfo>()
                    .Concat(fields.Cast<System.Reflection.MemberInfo>())
                    .Where(m => m.Name.ToLowerInvariant().Contains("texture") ||
                               m.Name.ToLowerInvariant().Contains("sprite") ||
                               m.Name.ToLowerInvariant().Contains("image") ||
                               m.Name.ToLowerInvariant().Contains("icon"))
                    .ToList();

                if (spriteRelatedMembers.Any())
                {
                    Logger.Info($"   üéØ Sprite/Texture-related members ({spriteRelatedMembers.Count}):");
                    foreach (var member in spriteRelatedMembers)
                    {
                        Logger.Info($"     üé® {member.Name} ({member.MemberType})");
                    }
                }

                Logger.Info($"üîç === END ASSET DUMP: {contextName} ===");
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error dumping asset properties for {contextName}: {ex.Message}");
            }
        }

        /// <summary>
        /// Formats a property value for readable logging
        /// </summary>
        private string FormatPropertyValue(object? value, Type valueType)
        {
            if (value == null) return "null";

            if (value is string str) return $"\"{str}\"";
            if (value is bool b) return b.ToString().ToLower();
            if (valueType.IsPrimitive) return value.ToString() ?? "null";

            if (value is IUnityObjectBase unityObj)
            {
                return $"{unityObj.GetType().Name}('{unityObj}')";
            }

            if (value is System.Collections.IEnumerable enumerable && !(value is string))
            {
                var items = enumerable.Cast<object>().Take(5).ToList();
                var preview = string.Join(", ", items.Select(i => i?.ToString() ?? "null"));
                return $"[{preview}{(items.Count == 5 ? "..." : "")}]";
            }

            return value.ToString() ?? "null";
        }

        /// <summary>
        /// Consolidates individual orb instances into families with levels
        /// </summary>
        private void ConsolidateOrbsIntoFamilies(UnifiedExtractionResult result, IProgress<string>? progress = null)
        {
            // Temporarily disabled due to compilation issues with BaseId and OrbFamily properties
            progress?.Report($"‚ö†Ô∏è Orb family consolidation temporarily disabled");
            return;

            /*try
            {
                progress?.Report($"üîÑ Consolidating {result.Orbs.Count} orbs into families...");
                
                // Group orbs by base ID
                var orbGroups = new Dictionary<string, List<AssetRipperOrbExtractor.OrbData>>();
                
                foreach (var orb in result.Orbs.Values)
                {
                    // Use BaseId if available, otherwise derive it
                    string baseId;
                    // TODO: Re-enable when BaseId property is available in OrbData
                    // if (!string.IsNullOrEmpty(orb.BaseId))
                    // {
                    //     baseId = orb.BaseId;
                    // }
                    // else
                    // {
                    // else
                    // {
                        // Fallback to deriving from ID/LocKey
                        var locKey = orb.LocKey ?? orb.Id;
                        baseId = StripLevelMarkers(locKey);
                    }
                    
                    if (!orbGroups.ContainsKey(baseId))
                    {
                        orbGroups[baseId] = new List<AssetRipperOrbExtractor.OrbData>();
                    }
                    orbGroups[baseId].Add(orb);
                }
                
                // Ensure localization is loaded
                var locService = Services.LocalizationService.Instance;
                locService.EnsureLoaded();
                
                // Create families from groups
                foreach (var group in orbGroups)
                {
                    var baseId = group.Key;
                    var orbs = group.Value.OrderBy(o => o.Level ?? 1).ToList();
                    var firstOrb = orbs.First();
                    
                    var family = new AssetRipperOrbExtractor.OrbFamily
                    {
                        Id = baseId,
                        LocKey = firstOrb.LocKey,
                        Name = firstOrb.Name ?? baseId,
                        Description = firstOrb.Description ?? "",
                        RarityValue = orbs.Select(o => o.RarityValue).Where(v => v.HasValue).DefaultIfEmpty().Max(),
                        Rarity = orbs.Select(o => o.Rarity).FirstOrDefault(r => !string.IsNullOrWhiteSpace(r)) ?? firstOrb.Rarity,
                        OrbType = orbs.Select(o => o.OrbType).FirstOrDefault(t => !string.IsNullOrWhiteSpace(t)) ?? firstOrb.OrbType,
                        Levels = new List<AssetRipperOrbExtractor.OrbLevelData>()
                    };
                    
                    // Choose sprite from orbs - prefer the most common sprite across levels, or Level 1's sprite
                    var spriteIds = orbs.Select(o => o.CorrelatedSpriteId).Where(s => !string.IsNullOrEmpty(s)).ToList();
                    if (spriteIds.Any())
                    {
                        // Find most common sprite
                        var mostCommonSprite = spriteIds
                            .GroupBy(s => s)
                            .OrderByDescending(g => g.Count())
                            .First()
                            .Key;
                        
                        family.CorrelatedSpriteId = mostCommonSprite;
                        
                        // Find the orb with this sprite to copy correlation details
                        var orbWithSprite = orbs.FirstOrDefault(o => o.CorrelatedSpriteId == mostCommonSprite);
                        if (orbWithSprite != null)
                        {
                            family.SpriteFilePath = orbWithSprite.SpriteFilePath;
                            family.CorrelationMethod = orbWithSprite.CorrelationMethod;
                            family.CorrelationConfidence = orbWithSprite.CorrelationConfidence;
                        }
                        
                        // Collect alternate sprites
                        family.AlternateSpriteIds = spriteIds.Distinct().Where(s => s != mostCommonSprite).ToList();
                    }
                    
                    // Add level data
                    foreach (var orb in orbs)
                    {
                        family.Levels.Add(new AssetRipperOrbExtractor.OrbLevelData
                        {
                            Level = orb.Level ?? 1,
                            DamagePerPeg = orb.DamagePerPeg,
                            CritDamagePerPeg = orb.CritDamagePerPeg,
                            RawData = orb.RawData ?? new Dictionary<string, object>(),
                            LeafId = orb.Id
                        });
                    }
                    
                    // Apply localization if possible
                    if (!string.IsNullOrWhiteSpace(family.LocKey))
                    {
                        // Try to get display name
                        var displayName = locService.GetTranslation(family.LocKey);
                        if (!string.IsNullOrWhiteSpace(displayName))
                        {
                            family.Name = displayName;
                        }
                        
                        // Try common description key patterns
                        var descriptionKeys = new[]
                        {
                            family.LocKey + "_DESC",
                            family.LocKey + "_Description",
                            family.LocKey + ".Description"
                        };
                        
                        foreach (var descKey in descriptionKeys)
                        {
                            var desc = locService.GetTranslation(descKey);
                            if (!string.IsNullOrWhiteSpace(desc))
                            {
                                family.Description = desc;
                                break;
                            }
                        }
                    }
                    
                    // Fallback to englishDescription from any level if still empty
                    if (string.IsNullOrWhiteSpace(family.Description))
                    {
                        family.Description = orbs
                            .Select(o => o.Description)
                            .FirstOrDefault(d => !string.IsNullOrWhiteSpace(d)) ?? "";
                    }
                    
                    result.OrbFamilies[baseId] = family;
                }
                
                progress?.Report($"‚úÖ Consolidated into {result.OrbFamilies.Count} orb families");
                
                // Log statistics
                var avgLevelsPerFamily = result.OrbFamilies.Values.Average(f => f.Levels.Count);
                var familiesWithSprites = result.OrbFamilies.Values.Count(f => !string.IsNullOrEmpty(f.CorrelatedSpriteId));
                Logger.Info($"Orb family statistics: {avgLevelsPerFamily:F1} average levels per family, {familiesWithSprites} families with sprites");
            }
            catch (Exception ex)
            {
                Logger.Error($"Error consolidating orbs into families: {ex.Message}");
                // Don't fail the entire extraction if consolidation fails
                result.OrbFamilies = new Dictionary<string, AssetRipperOrbExtractor.OrbFamily>();
            }
        }
        
        /// <summary>
        /// Strips level markers from an orb ID or locKey
        /// </summary>
        */ // Close the commented ConsolidateOrbsIntoFamilies method
        }

        private static string StripLevelMarkers(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;

            var res = s;
            // Strip suffixes like _L1, _L2, _Level1, _Level2, etc.
            res = System.Text.RegularExpressions.Regex.Replace(res, @"(_|\.)?_(L|Lvl|Level)\s*0*(\d+)$", string.Empty, System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            // Strip trailing digits that might be level indicators
            res = System.Text.RegularExpressions.Regex.Replace(res, @"(\d+)$", string.Empty);

            return string.IsNullOrWhiteSpace(res) ? s : res;
        }

        /// <summary>
        /// Extracts localization parameters from a LocalizationParamsManager component data
        /// Since AssetRipper doesn't properly deserialize the parameter structure,
        /// we'll use a fallback approach based on known orb parameter patterns
        /// </summary>
        private static Dictionary<string, string>? ExtractLocalizationParams(Dictionary<string, object> componentData)
        {
            try
            {
                // Look for _Params array to confirm this is a LocalizationParamsManager
                if (componentData.TryGetValue("_Params", out var paramsObj) &&
                    paramsObj is IEnumerable<object> paramsArray)
                {
                    var paramCount = paramsArray.Cast<object>().Count();
                    Logger.Debug($"üîç Found LocalizationParamsManager with {paramCount} parameters");
                    
                    // Since AssetRipper doesn't deserialize the parameters correctly,
                    // we'll return a placeholder that indicates we found a LocalizationParamsManager
                    // The actual parameter resolution will be handled by GetKnownLocalizationParams
                    return new Dictionary<string, string> { ["_HasLocalizationParams"] = "true" };
                }
            }
            catch (Exception ex)
            {
                Logger.Debug($"Failed to extract localization parameters: {ex.Message}");
            }
            
            return null;
        }

        /// <summary>
        /// Attempts to extract localization parameters directly from the raw SerializableStructure
        /// This bypasses the ConvertStructureToDict conversion which might be losing data
        /// </summary>
        private static Dictionary<string, string>? ExtractLocalizationParamsFromRawStructure(SerializableStructure structure)
        {
            try
            {
                // Look for _Params field in the raw structure
                if (structure.TryGetField("_Params", out var paramsValue))
                {
                    Logger.Debug($"üîç Raw _Params found, attempting to extract parameters...");
                    
                    if (paramsValue.CValue is System.Collections.IEnumerable enumerable)
                    {
                        var parameters = new Dictionary<string, string>();
                        var itemCount = 0;
                        
                        foreach (var item in enumerable)
                        {
                            itemCount++;
                            Logger.Debug($"üîç Raw param item {itemCount}: {item?.GetType().Name ?? "null"} = {item}");
                            
                            // If the item is a SerializableStructure, try to extract Name/Value
                            if (item is SerializableStructure paramStruct)
                            {
                                string? name = null, value = null;
                                
                                if (paramStruct.TryGetField("Name", out var nameField))
                                {
                                    name = nameField.AsString ?? nameField.CValue?.ToString();
                                }
                                
                                if (paramStruct.TryGetField("Value", out var valueField))
                                {
                                    value = valueField.AsString ?? valueField.CValue?.ToString();
                                }
                                
                                if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(value))
                                {
                                    parameters[name] = value;
                                    Logger.Debug($"üîç Extracted raw param: {name} = {value}");
                                }
                            }
                            // Handle other possible structures
                            else if (item != null)
                            {
                                Logger.Debug($"üîç Unhandled raw param item type: {item.GetType().FullName}");
                            }
                        }
                        
                        Logger.Debug($"üîç Extracted {parameters.Count} parameters from {itemCount} raw items");
                        return parameters.Count > 0 ? parameters : null;
                    }
                    else
                    {
                        Logger.Debug($"üîç Raw _Params CValue is not enumerable: {paramsValue.CValue?.GetType().Name ?? "null"}");
                    }
                }
                else
                {
                    Logger.Debug($"üîç No _Params field found in raw structure");
                }
            }
            catch (Exception ex)
            {
                Logger.Debug($"Error extracting from raw structure: {ex.Message}");
            }
            
            return null;
        }

        /// <summary>
        /// Gets known localization parameters for specific orbs based on game knowledge
        /// This is a fallback since AssetRipper doesn't properly parse LocalizationParamsManager
        /// </summary>
        private static Dictionary<string, string>? GetKnownLocalizationParams(string orbName, int level)
        {
            var orbNameLower = orbName.ToLowerInvariant();
            
            // Orbelisk parameters based on level
            if (orbNameLower.Contains("orbelisk"))
            {
                return level switch
                {
                    1 => new Dictionary<string, string>
                    {
                        ["STONE_BONUS_DMG"] = "1",
                        ["STONE_BONUS_CRIT"] = "1",
                        ["PERSIST_LEVEL"] = "1"
                    },
                    2 => new Dictionary<string, string>
                    {
                        ["STONE_BONUS_DMG"] = "1",
                        ["STONE_BONUS_CRIT"] = "1",
                        ["PERSIST_LEVEL"] = "1",
                        ["REG_DMG_TO_GIVE"] = "1",
                        ["CRIT_DMG_TO_GIVE"] = "1"
                    },
                    3 => new Dictionary<string, string>
                    {
                        ["STONE_BONUS_DMG"] = "2",
                        ["STONE_BONUS_CRIT"] = "2",
                        ["PERSIST_LEVEL"] = "1",
                        ["REG_DMG_TO_GIVE"] = "1",
                        ["CRIT_DMG_TO_GIVE"] = "1"
                    },
                    _ => new Dictionary<string, string>
                    {
                        ["STONE_BONUS_DMG"] = level.ToString(),
                        ["STONE_BONUS_CRIT"] = level.ToString(),
                        ["PERSIST_LEVEL"] = "1"
                    }
                };
            }
            
            // Add more orb parameter mappings here as needed
            // For now, return null for other orbs
            return null;
        }

        /// <summary>
        /// Resolves tokens in localization strings using provided parameters
        /// </summary>
        private static string ResolveTokens(string input, Dictionary<string, string> parameters)
        {
            if (string.IsNullOrEmpty(input) || parameters.Count == 0)
                return input;

            var result = input;
            
            // Replace tokens in format {[PARAMETER_NAME]}
            foreach (var param in parameters)
            {
                var token = $"{{[{param.Key}]}}";
                result = result.Replace(token, param.Value);
            }
            
            return result;
        }

        /// <summary>
        /// Resolves tokens in an array of localization strings
        /// </summary>
        private static List<string> ResolveTokens(List<string> inputs, Dictionary<string, string> parameters)
        {
            if (inputs == null || parameters.Count == 0)
                return inputs ?? new List<string>();

            return inputs.Select(input => ResolveTokens(input, parameters)).ToList();
        }

        /// <summary>
        /// Extract only global relic parameters from a collection without processing any entities
        /// </summary>
        private void ExtractGlobalParametersFromCollection(AssetCollection collection)
        {
            // Only process GameObjects to extract global localization parameters
            foreach (var asset in collection.Assets)
            {
                if (asset.Value is IGameObject gameObject)
                {
                    try
                    {
                        ExtractGlobalParametersFromGameObject(gameObject);
                    }
                    catch (Exception ex)
                    {
                        Logger.Debug($"Error extracting parameters from GameObject {gameObject.Name}: {ex.Message}");
                    }
                }
            }
        }

        /// <summary>
        /// Extract global relic parameters from a single GameObject if it contains LocalizationParamsManager
        /// </summary>
        private void ExtractGlobalParametersFromGameObject(IGameObject gameObject)
        {
            var components = gameObject.FetchComponents();
            if (components == null) return;

            foreach (var componentPtr in components)
            {
                var component = componentPtr.TryGetAsset(gameObject.Collection);
                if (component == null) continue;

                if (component is not IMonoBehaviour monoBehaviour) continue;

                var structure = monoBehaviour.LoadStructure();
                if (structure != null)
                {
                    // Try to extract localization parameters directly from the raw structure
                    var extractedParams = ExtractLocalizationParamsFromRawStructure(structure);
                    if (extractedParams != null && extractedParams.Count > 0)
                    {
                        // Store global relic parameters for later use with all relics
                        if (gameObject.Name.ToString().Contains("relic", StringComparison.OrdinalIgnoreCase))
                        {
                            Logger.Debug($"üî§ [Phase 1] Extracting global relic parameters from GameObject {gameObject.Name}: {extractedParams.Count} parameters");
                            
                            // Accumulate parameters instead of overwriting
                            if (_globalRelicParameters == null)
                            {
                                _globalRelicParameters = new Dictionary<string, string>(extractedParams);
                            }
                            else
                            {
                                foreach (var kvp in extractedParams)
                                {
                                    _globalRelicParameters[kvp.Key] = kvp.Value;
                                }
                                Logger.Debug($"üî§ [Phase 1] Total accumulated global relic parameters: {_globalRelicParameters.Count}");
                            }
                        }
                    }
                }
            }
        }

    }
}
